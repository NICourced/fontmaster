./cmake/fontmaster-config.cmake.in
@PACKAGE_INIT@

include("${CMAKE_CURRENT_LIST_DIR}/fontmaster-targets.cmake")

check_required_components(fontmaster)

--------------------------------

./src/core/Exceptions.h
#pragma once
#include <stdexcept>
#include <string>

namespace fontmaster {

class FontException : public std::runtime_error {
public:
    FontException(const std::string& message) : std::runtime_error(message) {}
};

class FontLoadException : public FontException {
public:
    FontLoadException(const std::string& filename, const std::string& reason)
        : FontException("Failed to load font '" + filename + "': " + reason) {}
};

class FontFormatException : public FontException {
public:
    FontFormatException(const std::string& format, const std::string& reason)
        : FontException("Unsupported font format '" + format + "': " + reason) {}
};

class FontSaveException : public FontException {
public:
    FontSaveException(const std::string& filename, const std::string& reason)
        : FontException("Failed to save font '" + filename + "': " + reason) {}
};

class GlyphNotFoundException : public FontException {
public:
    GlyphNotFoundException(const std::string& glyphName)
        : FontException("Glyph not found: " + glyphName) {}
};

class GlyphOperationException : public FontException {
public:
    GlyphOperationException(const std::string& operation, const std::string& reason)
        : FontException("Glyph operation '" + operation + "' failed: " + reason) {}
};

} // namespace fontmaster

--------------------------------

./src/core/FontMaster.cpp
#include "fontmaster/FontMaster.h"
#include "fontmaster/TTFUtils.h"
#include <unordered_map>
#include <vector>
#include <memory>
#include <fstream>
#include <map>
#include <iostream>

namespace fontmaster {

class FontMasterImpl {
private:
    std::vector<std::unique_ptr<FontFormatHandler>> handlers;
    std::map<FontFormat, FontFormatHandler*> handlerMap;
    
public:
    static FontMasterImpl& instance() {
        static FontMasterImpl instance;
        return instance;
    }
    
    void registerHandler(std::unique_ptr<FontFormatHandler> handler) {
        FontFormat format = handler->getFormat();
        handlers.push_back(std::move(handler));
        handlerMap[format] = handlers.back().get();
        std::cout << "Registered handler for format: " << static_cast<int>(format) << std::endl;
    }
    
    std::unique_ptr<Font> loadFont(const std::string& filepath) {
        // Сначала проверяем существование файла
        std::ifstream testFile(filepath, std::ios::binary);
        if (!testFile) {
            throw FontLoadException(filepath, "File not found or cannot be opened");
        }
        testFile.close();
        
        // Читаем данные файла для анализа
        std::ifstream file(filepath, std::ios::binary);
        file.seekg(0, std::ios::end);
        size_t size = file.tellg();
        file.seekg(0, std::ios::beg);
        
        if (size == 0) {
            throw FontLoadException(filepath, "File is empty");
        }
        
        std::vector<uint8_t> headerData(std::min(size, size_t(1024)), 0);
        file.read(reinterpret_cast<char*>(headerData.data()), headerData.size());
        file.close();
        
        // Пробуем все обработчики по порядку
        for (auto& handler : handlers) {
            try {
                if (handler->canHandle(filepath)) {
                    std::cout << "Loading font with handler: " << static_cast<int>(handler->getFormat()) << std::endl;
                    return handler->loadFont(filepath);
                }
            } catch (const std::exception& e) {
                std::cerr << "Handler error: " << e.what() << std::endl;
                continue;
            }
        }
        
        throw FontLoadException(filepath, "No suitable handler found for this font format");
    }
    
    FontFormat detectFormat(const std::string& filepath) {
        for (auto& handler : handlers) {
            if (handler->canHandle(filepath)) {
                return handler->getFormat();
            }
        }
        return FontFormat::UNKNOWN;
    }
    
    std::vector<FontFormat> getSupportedFormats() {
        std::vector<FontFormat> formats;
        for (auto& handler : handlers) {
            formats.push_back(handler->getFormat());
        }
        return formats;
    }
};

// Глобальная регистрация обработчиков
extern void registerCBDTHandler();
extern void registerSBIXHandler();
extern void registerCOLRHandler();
extern void registerSVGHandler();

static void registerAllHandlers() {
    // Регистрируем обработчики
    registerCBDTHandler();
    registerSBIXHandler();
    registerCOLRHandler();
    registerSVGHandler();
}

// Вызываем регистрацию при загрузке библиотеки
__attribute__((constructor))
static void initFontMaster() {
    std::cout << "Initializing FontMaster..." << std::endl;
    registerAllHandlers();
}

std::unique_ptr<Font> Font::load(const std::string& filepath) {
    return FontMasterImpl::instance().loadFont(filepath);
}

} // namespace fontmaster

--------------------------------

./src/utils/CFFParser.cpp
#include "fontmaster/CFFParser.h"
#include <iostream>
#include <algorithm>

namespace fontmaster {
namespace utils {

CFFParser::CFFParser(const std::vector<uint8_t>& data, uint32_t offset) 
    : fontData(data), baseOffset(offset) {}

bool CFFParser::parse() {
    if (fontData.size() < baseOffset + 4) {
        std::cerr << "CFF: Font data too small" << std::endl;
        return false;
    }

    size_t offset = baseOffset;
    const uint8_t* current = fontData.data() + baseOffset;

    // Parse CFF header
    uint8_t major = current[0];
    (void)current[1]; // minor
    uint8_t hdrSize = current[2];
    (void)current[3]; // offSize

    if (major != 1) {
        std::cerr << "CFF: Unsupported major version: " << static_cast<int>(major) << std::endl;
        return false;
    }

    offset = baseOffset + hdrSize;

    // Parse Name INDEX
    if (!parseIndex(offset)) {
        std::cerr << "CFF: Failed to parse Name INDEX" << std::endl;
        return false;
    }

    // Parse Top DICT INDEX
    if (!parseIndex(offset)) {
        std::cerr << "CFF: Failed to parse Top DICT INDEX" << std::endl;
        return false;
    }

    // Parse String INDEX
    if (!parseIndex(offset)) {
        std::cerr << "CFF: Failed to parse String INDEX" << std::endl;
        return false;
    }

    // Parse Global Subr INDEX
    if (!parseIndex(offset)) {
        std::cerr << "CFF: Failed to parse Global Subr INDEX" << std::endl;
        return false;
    }

    std::cout << "CFF: Successfully parsed CFF data" << std::endl;
    return true;
}

bool CFFParser::parseIndex(size_t& offset) {
    if (offset + 2 > fontData.size()) {
        return false;
    }

    const uint8_t* data = fontData.data() + offset;
    uint16_t count = (data[0] << 8) | data[1];

    if (count == 0) {
        offset += 2;
        return true;
    }

    if (offset + 2 + 1 > fontData.size()) {
        return false;
    }

    uint8_t offSize = data[2];
    // Убраны неиспользуемые переменные
    // size_t objectDataStart = indexStart + (count + 1) * offSize;

    // Calculate total index size
    size_t indexSize = 2 + 1 + (count + 1) * offSize;

    // Read offsets to calculate object data size
    (void)readOffset(data + 3, offSize); // firstOffset
    uint32_t lastOffset = readOffset(data + 3 + count * offSize, offSize);
    size_t objectDataSize = lastOffset - 1;

    indexSize += objectDataSize;

    if (offset + indexSize > fontData.size()) {
        return false;
    }

    offset += indexSize;
    return true;
}

uint32_t CFFParser::readOffset(const uint8_t* data, uint8_t offSize) {
    uint32_t offset = 0;
    for (uint8_t i = 0; i < offSize; ++i) {
        offset = (offset << 8) | data[i];
    }
    return offset;
}

} // namespace utils
} // namespace fontmaster

--------------------------------

./src/utils/TTFUtils.cpp
#include "fontmaster/TTFUtils.h"
#include <algorithm>
#include <fstream>

namespace fontmaster {
namespace utils {

std::vector<TableRecord> parseTTFTables(const std::vector<uint8_t>& fontData) {
    std::vector<TableRecord> tables;
    
    if (fontData.size() < sizeof(TTFHeader)) {
        throw std::runtime_error("Font data too small for TTF header");
    }
    
    const TTFHeader* header = reinterpret_cast<const TTFHeader*>(fontData.data());
    size_t expectedSize = sizeof(TTFHeader) + header->numTables * sizeof(TableRecord);
    
    if (fontData.size() < expectedSize) {
        throw std::runtime_error("Font data too small for table records");
    }
    
    const TableRecord* tableRecords = reinterpret_cast<const TableRecord*>(
        fontData.data() + sizeof(TTFHeader));
    
    for (uint16_t i = 0; i < header->numTables; ++i) {
        tables.push_back(tableRecords[i]);
    }
    
    return tables;
}

bool hasTable(const std::vector<TableRecord>& tables, const std::string& tableTag) {
    return std::any_of(tables.begin(), tables.end(), 
                      [&](const TableRecord& table) { 
                          return memcmp(table.tag, tableTag.c_str(), 4) == 0; 
                      });
}

const TableRecord* findTable(const std::vector<TableRecord>& tables, const std::string& tableTag) {
    for (const auto& table : tables) {
        if (memcmp(table.tag, tableTag.c_str(), 4) == 0) {
            return &table;
        }
    }
    return nullptr;
}

} // namespace utils
} // namespace fontmaster

--------------------------------

./src/utils/NAMEParser.cpp
#include "fontmaster/NAMEParser.h"
#include <iostream>
#include <algorithm>

namespace fontmaster {
namespace utils {

// Структура NameRecord должна быть определена в заголовочном файле
// Если её нет, добавляем её здесь
struct NameRecord {
    uint16_t platformID;
    uint16_t encodingID;
    uint16_t languageID;
    uint16_t nameID;
    std::string value;
};

NAMEParser::NAMEParser(const std::vector<uint8_t>& fontData) : fontData(fontData) {}

bool NAMEParser::parse() {
    if (fontData.size() < 6) {
        std::cerr << "NAME: Font data too small" << std::endl;
        return false;
    }

    uint16_t format = readUInt16(fontData.data());
    uint16_t count = readUInt16(fontData.data() + 2);
    uint16_t stringOffset = readUInt16(fontData.data() + 4);

    if (format != 0 && format != 1) {
        std::cerr << "NAME: Unsupported format: " << format << std::endl;
        return false;
    }

    std::cout << "NAME: Parsing " << count << " name records" << std::endl;

    for (uint16_t i = 0; i < count; ++i) {
        parseNameRecord(6 + i * 12, stringOffset);
    }

    std::cout << "NAME: Parsed " << nameRecords.size() << " name records" << std::endl;
    return true;
}

const std::vector<NAMEParser::NameRecord>& NAMEParser::getNameRecords() const { 
    return nameRecords; 
}

std::vector<NAMEParser::NameRecord> NAMEParser::getNameRecordsByID(uint16_t nameID) const {
    std::vector<NameRecord> result;
    for (const auto& record : nameRecords) {
        if (record.nameID == nameID) {
            result.push_back(record);
        }
    }
    return result;
}

std::vector<NAMEParser::NameRecord> NAMEParser::getPostScriptNames() const {
    return getNameRecordsByID(6); // Name ID 6 is PostScript name
}

void NAMEParser::parseNameRecord(uint32_t recordOffset, uint16_t stringOffset) {
    if (recordOffset + 12 > fontData.size()) {
        std::cerr << "NAME: Name record extends beyond font data" << std::endl;
        return;
    }

    NameRecord nameRecord;
    nameRecord.platformID = readUInt16(fontData.data() + recordOffset);
    nameRecord.encodingID = readUInt16(fontData.data() + recordOffset + 2);
    nameRecord.languageID = readUInt16(fontData.data() + recordOffset + 4);
    nameRecord.nameID = readUInt16(fontData.data() + recordOffset + 6);
    uint16_t length = readUInt16(fontData.data() + recordOffset + 8);
    uint16_t offset = readUInt16(fontData.data() + recordOffset + 10);

    uint32_t stringStart = stringOffset + offset;
    if (stringStart + length <= fontData.size()) {
        nameRecord.value = readString(fontData.data() + stringStart, length, 
                                    nameRecord.platformID, nameRecord.encodingID);
    } else {
        std::cerr << "NAME: String data extends beyond font data" << std::endl;
        nameRecord.value = "";
    }

    nameRecords.push_back(nameRecord);

    // For format 1, handle language tag records
    if (nameRecord.nameID == 0 && nameRecord.platformID == 1) {
        // This is a copyright notice that might contain language info
        std::cout << "NAME: Copyright: " << nameRecord.value << std::endl;
    }
}

std::string NAMEParser::readString(const uint8_t* data, uint16_t length, 
                                  uint16_t platformID, uint16_t encodingID) {
    std::string result;
    
    if (platformID == 1) { // Macintosh
        result = readMacString(data, length);
    } else if (platformID == 3) { // Windows
        result = readWindowsString(data, length, encodingID);
    } else if (platformID == 0) { // Unicode
        result = readUnicodeString(data, length);
    } else {
        // Fallback: read as ASCII
        for (uint16_t i = 0; i < length; ++i) {
            if (data[i] >= 32 && data[i] <= 126) {
                result += static_cast<char>(data[i]);
            }
        }
    }
    
    return result;
}

std::string NAMEParser::readMacString(const uint8_t* data, uint16_t length) {
    std::string result;
    for (uint16_t i = 0; i < length; ++i) {
        // Simple MacRoman to ASCII conversion
        if (data[i] >= 32 && data[i] <= 126) {
            result += static_cast<char>(data[i]);
        } else if (data[i] == 0xA9) {
            result += "(c)"; // Copyright symbol
        } else {
            result += '?';
        }
    }
    return result;
}

std::string NAMEParser::readWindowsString(const uint8_t* data, uint16_t length, uint16_t encodingID) {
    std::string result;
    
    if (encodingID == 1 || encodingID == 10) { // UCS-2 or UCS-4
        // Simple UCS-2 to UTF-8 conversion (basic)
        for (uint16_t i = 0; i + 1 < length; i += 2) {
            uint16_t codePoint = (static_cast<uint16_t>(data[i]) << 8) | data[i + 1];
            if (codePoint == 0) break;
            
            if (codePoint < 0x80) {
                result += static_cast<char>(codePoint);
            } else if (codePoint < 0x800) {
                result += static_cast<char>(0xC0 | (codePoint >> 6));
                result += static_cast<char>(0x80 | (codePoint & 0x3F));
            } else {
                result += static_cast<char>(0xE0 | (codePoint >> 12));
                result += static_cast<char>(0x80 | ((codePoint >> 6) & 0x3F));
                result += static_cast<char>(0x80 | (codePoint & 0x3F));
            }
        }
    } else {
        // Fallback: read as ASCII
        for (uint16_t i = 0; i < length; ++i) {
            if (data[i] >= 32 && data[i] <= 126) {
                result += static_cast<char>(data[i]);
            }
        }
    }
    
    return result;
}

std::string NAMEParser::readUnicodeString(const uint8_t* data, uint16_t length) {
    std::string result;
    
    // Basic Unicode (UTF-16BE) to UTF-8 conversion
    for (uint16_t i = 0; i + 1 < length; i += 2) {
        uint16_t codePoint = (static_cast<uint16_t>(data[i]) << 8) | data[i + 1];
        if (codePoint == 0) break;
        
        if (codePoint < 0x80) {
            result += static_cast<char>(codePoint);
        } else if (codePoint < 0x800) {
            result += static_cast<char>(0xC0 | (codePoint >> 6));
            result += static_cast<char>(0x80 | (codePoint & 0x3F));
        } else {
            // Handle surrogate pairs for UTF-16
            if (codePoint >= 0xD800 && codePoint <= 0xDBFF && i + 3 < length) {
                // High surrogate
                uint16_t highSurrogate = codePoint;
                uint16_t lowSurrogate = (static_cast<uint16_t>(data[i + 2]) << 8) | data[i + 3];
                
                if (lowSurrogate >= 0xDC00 && lowSurrogate <= 0xDFFF) {
                    uint32_t fullCodePoint = 0x10000 + ((highSurrogate - 0xD800) << 10) + (lowSurrogate - 0xDC00);
                    
                    result += static_cast<char>(0xF0 | (fullCodePoint >> 18));
                    result += static_cast<char>(0x80 | ((fullCodePoint >> 12) & 0x3F));
                    result += static_cast<char>(0x80 | ((fullCodePoint >> 6) & 0x3F));
                    result += static_cast<char>(0x80 | (fullCodePoint & 0x3F));
                    
                    i += 2; // Skip the low surrogate we just processed
                    continue;
                }
            }
            
            // Regular UTF-8 encoding
            result += static_cast<char>(0xE0 | (codePoint >> 12));
            result += static_cast<char>(0x80 | ((codePoint >> 6) & 0x3F));
            result += static_cast<char>(0x80 | (codePoint & 0x3F));
        }
    }
    
    return result;
}

uint16_t NAMEParser::readUInt16(const uint8_t* data) {
    return (static_cast<uint16_t>(data[0]) << 8) | data[1];
}

} // namespace utils
} // namespace fontmaster

--------------------------------

./src/utils/POSTParser.cpp
#include "fontmaster/TTFUtils.h"
#include <vector>
#include <map>
#include <string>
#include <stdexcept>
#include <iostream>

namespace fontmaster {
namespace utils {

class POSTParser {
private:
    const std::vector<uint8_t>& fontData;
    uint32_t postOffset;
    std::map<uint16_t, std::string> glyphNames;
    std::vector<std::string> standardNames;
    uint16_t numGlyphs;
    
    // Стандартные имена глифов Macintosh (258 names)
    const char* macStandardNames[258] = {
        ".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign",
        "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk",
        "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four",
        "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater",
        "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N",
        "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash",
        "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g",
        "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y",
        "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla",
        "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis",
        "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute",
        "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis",
        "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling",
        "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute",
        "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal",
        "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine",
        "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin",
        "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace",
        "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright",
        "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency",
        "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase",
        "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave",
        "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve",
        "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent",
        "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron",
        "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus",
        "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters",
        "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron",
        "ccaron", "dcroat"
    };
    
public:
    POSTParser(const std::vector<uint8_t>& data, uint32_t offset, uint16_t glyphCount) 
        : fontData(data), postOffset(offset), numGlyphs(glyphCount) {
        initializeStandardNames();
    }
    
    bool parse() {
        try {
            if (postOffset + 32 > fontData.size()) {
                return false;
            }
            
            const uint8_t* data = fontData.data() + postOffset;
            
            uint32_t version = readUInt32(data);
            // Пропускаем остальные поля заголовка, они не нужны для имен глифов
            
            // Парсим в зависимости от версии
            switch (version) {
                case 0x00010000: // Version 1.0
                    return parseVersion1();
                case 0x00020000: // Version 2.0
                    return parseVersion2(data);
                case 0x00025000: // Version 2.5
                    return parseVersion25(data);
                case 0x00030000: // Version 3.0
                    return parseVersion3();
                default:
                    std::cerr << "Unsupported POST table version: " << std::hex << version << std::dec << std::endl;
                    return false;
            }
        } catch (const std::exception& e) {
            std::cerr << "POST table parsing error: " << e.what() << std::endl;
            return false;
        }
    }
    
    const std::map<uint16_t, std::string>& getGlyphNames() const { return glyphNames; }
    
private:
    void initializeStandardNames() {
        for (int i = 0; i < 258; i++) {
            standardNames.push_back(macStandardNames[i]);
        }
    }
    
    uint16_t readUInt16(const uint8_t* data) {
        return (data[0] << 8) | data[1];
    }
    
    uint32_t readUInt32(const uint8_t* data) {
        return (data[0] << 24) | (data[1] << 16) | (data[2] << 8) | data[3];
    }
    
    int16_t readInt16(const uint8_t* data) {
        return static_cast<int16_t>(readUInt16(data));
    }
    
    int8_t readInt8(const uint8_t* data) {
        return static_cast<int8_t>(data[0]);
    }
    
    bool parseVersion1() {
        // Version 1.0: Все глифы используют стандартные имена Macintosh
        for (uint16_t glyphID = 0; glyphID < numGlyphs && glyphID < standardNames.size(); glyphID++) {
            glyphNames[glyphID] = standardNames[glyphID];
        }
        return true;
    }
    
    bool parseVersion2(const uint8_t* data) {
        // Version 2.0: Массив индексов имен
        uint16_t numGlyphsInTable = readUInt16(data + 32);
        
        // Используем минимальное значение между количеством из MAXP и POST
        uint16_t actualNumGlyphs = std::min(numGlyphs, numGlyphsInTable);
        
        if (postOffset + 34 + actualNumGlyphs * 2 > fontData.size()) {
            return false;
        }
        
        const uint16_t* glyphNameIndex = reinterpret_cast<const uint16_t*>(data + 32);
        
        // Вычисляем смещение до строковых данных
        uint16_t stringDataOffset = 34 + numGlyphsInTable * 2;
        
        for (uint16_t glyphID = 0; glyphID < actualNumGlyphs; glyphID++) {
            uint16_t nameIndex = glyphNameIndex[glyphID];
            
            if (nameIndex < 258) {
                // Стандартное имя
                if (nameIndex < standardNames.size()) {
                    glyphNames[glyphID] = standardNames[nameIndex];
                } else {
                    glyphNames[glyphID] = "bad_index_" + std::to_string(nameIndex);
                }
            } else {
                // Кастомное имя в строковых данных
                uint32_t customNameOffset = nameIndex - 258;
                uint32_t stringTableOffset = stringDataOffset + customNameOffset;
                
                if (stringTableOffset + 1 > fontData.size()) {
                    glyphNames[glyphID] = "invalid_offset_" + std::to_string(nameIndex);
                    continue;
                }
                
                // Читаем длину строки
                uint8_t nameLength = fontData[postOffset + stringTableOffset];
                
                if (stringTableOffset + 1 + nameLength > fontData.size()) {
                    glyphNames[glyphID] = "invalid_length_" + std::to_string(nameIndex);
                    continue;
                }
                
                // Читаем саму строку
                const uint8_t* nameData = fontData.data() + postOffset + stringTableOffset + 1;
                std::string name(reinterpret_cast<const char*>(nameData), nameLength);
                
                glyphNames[glyphID] = name;
            }
        }
        
        return true;
    }
    
    bool parseVersion25(const uint8_t* data) {
        // Version 2.5: Смещения от стандартных имен
        uint16_t numGlyphsInTable = readUInt16(data + 32);
        uint16_t actualNumGlyphs = std::min(numGlyphs, numGlyphsInTable);
        
        if (postOffset + 34 + actualNumGlyphs > fontData.size()) {
            return false;
        }
        
        const int8_t* offsetArray = reinterpret_cast<const int8_t*>(data + 32);
        
        for (uint16_t glyphID = 0; glyphID < actualNumGlyphs; glyphID++) {
            int8_t offset = offsetArray[glyphID];
            int32_t nameIndex = glyphID + offset;
            
            if (nameIndex >= 0 && nameIndex < static_cast<int32_t>(standardNames.size())) {
                glyphNames[glyphID] = standardNames[nameIndex];
            } else {
                glyphNames[glyphID] = "bad_offset_" + std::to_string(nameIndex);
            }
        }
        
        return true;
    }
    
    bool parseVersion3() {
        // Version 3.0: Нет имен глифов в таблице
        // Генерируем имена на основе glyphID
        for (uint16_t glyphID = 0; glyphID < numGlyphs; glyphID++) {
            glyphNames[glyphID] = "glyph" + std::to_string(glyphID);
        }
        return true;
    }
};

} // namespace utils
} // namespace fontmaster

--------------------------------

./src/utils/MAXPParser.cpp
#include "fontmaster/TTFUtils.h"
#include <vector>
#include <stdexcept>
#include <iostream>

namespace fontmaster {
namespace utils {

class MAXPParser {
private:
    const std::vector<uint8_t>& fontData;
    uint32_t maxpOffset;
    uint16_t numGlyphs;
    uint16_t maxPoints;
    uint16_t maxContours;
    uint16_t maxCompositePoints;
    uint16_t maxCompositeContours;
    uint16_t maxZones;
    uint16_t maxTwilightPoints;
    uint16_t maxStorage;
    uint16_t maxFunctionDefs;
    uint16_t maxInstructionDefs;
    uint16_t maxStackElements;
    uint16_t maxSizeOfInstructions;
    uint16_t maxComponentElements;
    uint16_t maxComponentDepth;
    
public:
    MAXPParser(const std::vector<uint8_t>& data, uint32_t offset) 
        : fontData(data), maxpOffset(offset), numGlyphs(0), maxPoints(0), maxContours(0),
          maxCompositePoints(0), maxCompositeContours(0), maxZones(0), maxTwilightPoints(0),
          maxStorage(0), maxFunctionDefs(0), maxInstructionDefs(0), maxStackElements(0),
          maxSizeOfInstructions(0), maxComponentElements(0), maxComponentDepth(0) {}
    
    bool parse() {
        try {
            if (maxpOffset + 6 > fontData.size()) {
                return false;
            }
            
            const uint8_t* data = fontData.data() + maxpOffset;
            
            uint32_t version = readUInt32(data);
            numGlyphs = readUInt16(data + 4);
            
            if (version == 0x00010000 && maxpOffset + 32 <= fontData.size()) {
                // Version 1.0 - читаем все поля
                maxPoints = readUInt16(data + 6);
                maxContours = readUInt16(data + 8);
                maxCompositePoints = readUInt16(data + 10);
                maxCompositeContours = readUInt16(data + 12);
                maxZones = readUInt16(data + 14);
                maxTwilightPoints = readUInt16(data + 16);
                maxStorage = readUInt16(data + 18);
                maxFunctionDefs = readUInt16(data + 20);
                maxInstructionDefs = readUInt16(data + 22);
                maxStackElements = readUInt16(data + 24);
                maxSizeOfInstructions = readUInt16(data + 26);
                maxComponentElements = readUInt16(data + 28);
                maxComponentDepth = readUInt16(data + 30);
            }
            
            return true;
        } catch (const std::exception& e) {
            std::cerr << "MAXP table parsing error: " << e.what() << std::endl;
            return false;
        }
    }
    
    uint16_t getNumGlyphs() const { return numGlyphs; }
    uint16_t getMaxPoints() const { return maxPoints; }
    uint16_t getMaxContours() const { return maxContours; }
    uint16_t getMaxCompositePoints() const { return maxCompositePoints; }
    uint16_t getMaxCompositeContours() const { return maxCompositeContours; }
    uint16_t getMaxComponentDepth() const { return maxComponentDepth; }
    
private:
    uint16_t readUInt16(const uint8_t* data) {
        return (data[0] << 8) | data[1];
    }
    
    uint32_t readUInt32(const uint8_t* data) {
        return (data[0] << 24) | (data[1] << 16) | (data[2] << 8) | data[3];
    }
};

} // namespace utils
} // namespace fontmaster

--------------------------------

./src/utils/CMAPParser.cpp
#ifndef CMAPPARSER_H
#define CMAPPARSER_H

#include <vector>
#include <map>
#include <set>
#include <cstdint>
#include <string>
#include <stdexcept>
#include <iostream>

namespace fontmaster {
namespace utils {

struct CMAPRange {
    uint32_t startChar;
    uint32_t endChar;
    uint16_t startGlyph;
};

class CMAPParser {
public:
    CMAPParser(const std::vector<uint8_t>& fontData, bool verbose = false)
        : fontData(fontData), verbose(verbose) {}

    void parse() {
        if (fontData.size() < 4)
            throw std::runtime_error("CMAP: Font data too small");

        uint16_t version = readUInt16(fontData.data());
        uint16_t numTables = readUInt16(fontData.data() + 2);

        if (version != 0)
            throw std::runtime_error("CMAP: Unsupported version: " + std::to_string(version));

        if (verbose) std::cout << "CMAP: Parsing " << numTables << " subtables\n";

        for (uint16_t i = 0; i < numTables; ++i) {
            uint32_t tableOffset = 4 + i * 8;
            if (tableOffset + 8 > fontData.size())
                throw std::runtime_error("CMAP: Table record out of bounds");

            uint16_t platformID = readUInt16(fontData.data() + tableOffset);
            uint16_t encodingID = readUInt16(fontData.data() + tableOffset + 2);
            uint32_t subtableOffset = readUInt32(fontData.data() + tableOffset + 4);

            if (subtableOffset >= fontData.size())
                throw std::runtime_error("CMAP: Subtable offset out of bounds");

            parseSubtable(subtableOffset, platformID, encodingID);
        }
    }

    uint16_t getGlyphIndex(uint32_t charCode) const {
        auto it = charToGlyph.find(charCode);
        if (it != charToGlyph.end()) return it->second;

        // Быстрый поиск в диапазонах
        for (const auto& range : ranges) {
            if (charCode >= range.startChar && charCode <= range.endChar) {
                return static_cast<uint16_t>(range.startGlyph + (charCode - range.startChar));
            }
        }
        return 0;
    }

    std::set<uint32_t> getCharCodes(uint16_t glyphIndex) const {
        std::set<uint32_t> codes;
        auto it = glyphToChar.find(glyphIndex);
        if (it != glyphToChar.end()) codes = it->second;

        for (const auto& range : ranges) {
            if (glyphIndex >= range.startGlyph && glyphIndex <= range.startGlyph + (range.endChar - range.startChar)) {
                for (uint32_t c = range.startChar; c <= range.endChar; ++c) {
                    if (range.startGlyph + (c - range.startChar) == glyphIndex)
                        codes.insert(c);
                }
            }
        }
        return codes;
    }

private:
    const std::vector<uint8_t>& fontData;
    std::map<uint32_t, uint16_t> charToGlyph;
    std::map<uint16_t, std::set<uint32_t>> glyphToChar;
    std::vector<CMAPRange> ranges;
    bool verbose;

    void parseSubtable(uint32_t offset, uint16_t platformID, uint16_t encodingID) {
        if (offset + 2 > fontData.size()) return;
        uint16_t format = readUInt16(fontData.data() + offset);

        switch (format) {
            case 0: parseFormat0(offset); break;
            case 2: parseFormat2(offset); break;
            case 4: parseFormat4(offset); break;
            case 6: parseFormat6(offset); break;
            case 8: parseFormat8(offset); break;
            case 10: parseFormat10(offset); break;
            case 12: parseFormat12(offset); break;
            case 13: parseFormat13(offset); break;
            case 14: parseFormat14(offset); break;
            default:
                if (verbose) std::cout << "CMAP: Unsupported format: " << format << "\n";
                break;
        }
    }

    // ======================= Форматы =========================
    void parseFormat0(uint32_t offset) {
        if (offset + 6 + 256 > fontData.size()) throw std::runtime_error("CMAP: Format 0 too small");
        for (int i = 0; i < 256; ++i) {
            uint8_t g = fontData[offset + 6 + i];
            if (g != 0) {
                charToGlyph[i] = g;
                glyphToChar[g].insert(i);
            }
        }
        if (verbose) std::cout << "CMAP: Format 0 parsed\n";
    }

    void parseFormat2(uint32_t offset) {
        if (verbose) std::cout << "CMAP: Format 2 (high-byte mapping) not fully implemented\n";
    }

    void parseFormat4(uint32_t offset) {
        if (offset + 14 > fontData.size()) throw std::runtime_error("CMAP: Format 4 too small");
        uint16_t segCountX2 = readUInt16Safe(offset + 6);
        uint16_t segCount = segCountX2 / 2;

        uint32_t endCountOffset = offset + 14;
        uint32_t startCountOffset = endCountOffset + segCountX2 + 2;
        uint32_t idDeltaOffset = startCountOffset + segCountX2;
        uint32_t idRangeOffsetOffset = idDeltaOffset + segCountX2;

        for (uint16_t i = 0; i < segCount; ++i) {
            uint16_t endCount = readUInt16Safe(endCountOffset + i * 2);
            uint16_t startCount = readUInt16Safe(startCountOffset + i * 2);
            int16_t idDelta = readInt16Safe(idDeltaOffset + i * 2);
            uint16_t idRangeOffset = readUInt16Safe(idRangeOffsetOffset + i * 2);

            if (startCount == 0xFFFF && endCount == 0xFFFF) break;

            for (uint32_t c = startCount; c <= endCount; ++c) {
                uint16_t glyph = 0;
                if (idRangeOffset == 0) {
                    glyph = (c + idDelta) & 0xFFFF;
                } else {
                    uint32_t glyphOffset = idRangeOffsetOffset + i * 2 + idRangeOffset + (c - startCount) * 2;
                    if (glyphOffset + 2 <= fontData.size()) {
                        glyph = readUInt16(fontData.data() + glyphOffset);
                        if (glyph != 0) glyph = (glyph + idDelta) & 0xFFFF;
                    }
                }
                if (glyph != 0) {
                    charToGlyph[c] = glyph;
                    glyphToChar[glyph].insert(c);
                }
            }
        }
        if (verbose) std::cout << "CMAP: Format 4 parsed\n";
    }

    void parseFormat6(uint32_t offset) {
        uint16_t firstCode = readUInt16Safe(offset + 6);
        uint16_t entryCount = readUInt16Safe(offset + 8);
        for (uint16_t i = 0; i < entryCount; ++i) {
            uint16_t g = readUInt16Safe(offset + 10 + i * 2);
            if (g != 0) {
                charToGlyph[firstCode + i] = g;
                glyphToChar[g].insert(firstCode + i);
            }
        }
        if (verbose) std::cout << "CMAP: Format 6 parsed\n";
    }

    void parseFormat8(uint32_t offset) {
        if (verbose) std::cout << "CMAP: Format 8 (mixed 16/32-bit) not implemented\n";
    }

    void parseFormat10(uint32_t offset) {
        if (verbose) std::cout << "CMAP: Format 10 (32-bit) not implemented\n";
    }

    void parseFormat12(uint32_t offset) {
        uint32_t numGroups = readUInt32Safe(offset + 12);
        for (uint32_t i = 0; i < numGroups; ++i) {
            uint32_t groupOffset = offset + 16 + i * 12;
            uint32_t startChar = readUInt32Safe(groupOffset);
            uint32_t endChar = readUInt32Safe(groupOffset + 4);
            uint16_t startGlyph = static_cast<uint16_t>(readUInt32Safe(groupOffset + 8));

            ranges.push_back({startChar, endChar, startGlyph});
        }
        if (verbose) std::cout << "CMAP: Format 12 parsed\n";
    }

    void parseFormat13(uint32_t offset) {
        uint32_t numGroups = readUInt32Safe(offset + 12);
        for (uint32_t i = 0; i < numGroups; ++i) {
            uint32_t groupOffset = offset + 16 + i * 12;
            uint32_t startChar = readUInt32Safe(groupOffset);
            uint32_t endChar = readUInt32Safe(groupOffset + 4);
            uint16_t glyph = static_cast<uint16_t>(readUInt32Safe(groupOffset + 8));
            for (uint32_t c = startChar; c <= endChar; ++c) {
                charToGlyph[c] = glyph;
                glyphToChar[glyph].insert(c);
            }
        }
        if (verbose) std::cout << "CMAP: Format 13 parsed\n";
    }

    void parseFormat14(uint32_t offset) {
        if (verbose) std::cout << "CMAP: Format 14 (variation selectors) not implemented\n";
    }

    // ======================= Чтение данных =========================
    uint16_t readUInt16(const uint8_t* data) { return (data[0] << 8) | data[1]; }
    uint32_t readUInt32(const uint8_t* data) { return (data[0] << 24) | (data[1] << 16) | (data[2] << 8) | data[3]; }
    int16_t readInt16(const uint8_t* data) { return (int16_t)((data[0] << 8) | data[1]); }

    uint16_t readUInt16Safe(uint32_t offset) {
        if (offset + 2 > fontData.size()) throw std::runtime_error("CMAP: readUInt16Safe out of bounds");
        return readUInt16(fontData.data() + offset);
    }

    uint32_t readUInt32Safe(uint32_t offset) {
        if (offset + 4 > fontData.size()) throw std::runtime_error("CMAP: readUInt32Safe out of bounds");
        return readUInt32(fontData.data() + offset);
    }

    int16_t readInt16Safe(uint32_t offset) {
        if (offset + 2 > fontData.size()) throw std::runtime_error("CMAP: readInt16Safe out of bounds");
        return readInt16(fontData.data() + offset);
    }
};

} // namespace utils
} // namespace fontmaster

#endif // CMAPPARSER_H

--------------------------------

./src/utils/TTFRebuilder.cpp
#include "fontmaster/TTFRebuilder.h"
#include "fontmaster/TTFUtils.h"
#include <algorithm>
#include <stdexcept>
#include <iostream>
#include <cstring>
#include <functional>
#include <cmath>
#include <map>
#include <set>
#include <sstream>
#include <iomanip>
#include <ctime>

namespace fontmaster {

// Константы для таблиц
const uint32_t TTF_MAGIC = 0x00010000;
const uint32_t HEAD_MAGIC = 0x5F0F3CF5;
const size_t HEAD_TABLE_SIZE = 54;
const size_t MAXP_TABLE_SIZE = 32;
const size_t HHEA_TABLE_SIZE = 36;
const size_t OS2_TABLE_SIZE = 96;

// Максимальный индекс для стандартных имен глифов
const uint16_t MAX_STANDARD_NAME_INDEX = 32767;

TTFRebuilder::TTFRebuilder(const std::vector<uint8_t>& fontData) 
    : originalData(fontData), numGlyphs(0), numHMetrics(0), locaShortFormat(false) {
    
    // Регистрируем обработчики для таблиц, требующих специальной логики
    rebuildHandlers["glyf"] = [this](const std::string& tag) { rebuildGlyfTable(tag); };
    rebuildHandlers["loca"] = [this](const std::string& tag) { rebuildLocaTable(tag); };
    rebuildHandlers["hmtx"] = [this](const std::string& tag) { rebuildHmtxTable(tag); };
    rebuildHandlers["hhea"] = [this](const std::string& tag) { rebuildHheaTable(tag); };
    rebuildHandlers["maxp"] = [this](const std::string& tag) { rebuildMaxpTable(tag); };
    rebuildHandlers["name"] = [this](const std::string& tag) { rebuildNameTable(tag); };
    rebuildHandlers["OS/2"] = [this](const std::string& tag) { rebuildOS2Table(tag); };
    rebuildHandlers["head"] = [this](const std::string& tag) { rebuildHeadTable(tag); };
    rebuildHandlers["post"] = [this](const std::string& tag) { rebuildPostTable(tag); };
    
    try {
        parseOriginalStructure();
        
        // Парсим необходимые таблицы для инициализации
        if (!parseHeadTable()) {
            throw std::runtime_error("Failed to parse head table");
        }
        if (!parseMaxpTable()) {
            throw std::runtime_error("Failed to parse maxp table");
        }
        if (!parseHheaTable()) {
            throw std::runtime_error("Failed to parse hhea table");
        }
        if (!parseLocaTable()) {
            throw std::runtime_error("Failed to parse loca table");
        }
        
        parseGlyfTable();
        
    } catch (const std::exception& e) {
        std::cerr << "TTFRebuilder initialization error: " << e.what() << std::endl;
        throw;
    }
}

void TTFRebuilder::parseOriginalStructure() {
    if (originalData.size() < sizeof(utils::TTFHeader)) {
        throw std::runtime_error("Font data too small for TTF header");
    }
    
    auto tableRecords = utils::parseTTFTables(originalData);
    
    if (tableRecords.empty()) {
        throw std::runtime_error("No tables found in font data");
    }
    
    for (const auto& record : tableRecords) {
        TableInfo info;
        info.tag = std::string(record.tag, 4);
        info.originalOffset = record.offset;
        info.originalLength = record.length;
        info.newOffset = 0;
        info.newLength = record.length;
        info.modified = false;
        
        // Копируем оригинальные данные таблицы
        if (record.offset + record.length <= originalData.size()) {
            info.data.assign(originalData.begin() + record.offset, 
                           originalData.begin() + record.offset + record.length);
        } else {
            throw std::runtime_error("Table " + info.tag + " extends beyond font data");
        }
        
        tables[info.tag] = info;
        tableOrder.push_back(info.tag);
    }
    
    std::cout << "TTFRebuilder: Parsed " << tableOrder.size() << " tables" << std::endl;
}

void TTFRebuilder::markTableModified(const std::string& tag) {
    auto it = tables.find(tag);
    if (it != tables.end()) {
        it->second.modified = true;
        std::cout << "TTFRebuilder: Marked table '" << tag << "' as modified" << std::endl;
    } else {
        throw std::runtime_error("Table '" + tag + "' not found");
    }
}

void TTFRebuilder::setTableData(const std::string& tag, const std::vector<uint8_t>& data) {
    auto it = tables.find(tag);
    if (it != tables.end()) {
        it->second.data = data;
        it->second.newLength = data.size();
        it->second.modified = true;
        std::cout << "TTFRebuilder: Set table '" << tag << "' data, size: " 
                  << data.size() << " bytes" << std::endl;
    } else {
        throw std::runtime_error("Table '" + tag + "' not found");
    }
}

const std::vector<uint8_t>* TTFRebuilder::getTableData(const std::string& tag) const {
    auto it = tables.find(tag);
    if (it != tables.end()) {
        return &it->second.data;
    }
    return nullptr;
}

bool TTFRebuilder::hasTable(const std::string& tag) const {
    return tables.find(tag) != tables.end();
}

void TTFRebuilder::setTableRebuildHandler(const std::string& tag, 
                                         std::function<void(const std::string&)> handler) {
    rebuildHandlers[tag] = handler;
    std::cout << "TTFRebuilder: Set custom rebuild handler for table '" << tag << "'" << std::endl;
}

std::vector<uint8_t> TTFRebuilder::rebuild() {
    newData.clear();
    
    try {
        // 1. Пересобираем модифицированные таблицы
        for (auto& pair : tables) {
            if (pair.second.modified) {
                rebuildTable(pair.first);
            }
        }
        
        // 2. Синхронизируем связанные таблицы
        updateGlyfTable();
        updateLocaTable();
        updateHmtxTable();
        updateHheaTable();
        updateMaxpTable();
        
        // 3. Пересчитываем глобальные метрики шрифта
        recalculateFontMetrics();
        
        // 4. Рассчитываем новые смещения
        updateTableOffsets();
        
        // 5. Собираем новый заголовок и директорию таблиц
        rebuildTableDirectory();
        
        // 6. Копируем данные всех таблиц
        for (const auto& tag : tableOrder) {
            const auto& tableInfo = tables[tag];
            size_t requiredSize = tableInfo.newOffset + tableInfo.newLength;
            if (newData.size() < requiredSize) {
                newData.resize(requiredSize);
            }
            
            std::copy(tableInfo.data.begin(), tableInfo.data.end(), 
                     newData.begin() + tableInfo.newOffset);
            
            // Выравнивание до 4 байт
            size_t alignedSize = (tableInfo.newLength + 3) & ~3;
            if (alignedSize > tableInfo.newLength) {
                std::fill(newData.begin() + tableInfo.newOffset + tableInfo.newLength,
                         newData.begin() + tableInfo.newOffset + alignedSize, 0);
            }
        }
        
        // 7. Обновляем checksum adjustment в head таблице
        updateHeadTableChecksumAdjustment();
        
        std::cout << "TTFRebuilder: Successfully rebuilt font, original size: " 
                  << originalData.size() << " bytes, new size: " << newData.size() 
                  << " bytes" << std::endl;
        
        return newData;
        
    } catch (const std::exception& e) {
        std::cerr << "TTFRebuilder::rebuild error: " << e.what() << std::endl;
        throw;
    }
}

void TTFRebuilder::rebuildTable(const std::string& tag) {
    auto it = tables.find(tag);
    if (it == tables.end()) {
        throw std::runtime_error("Table '" + tag + "' not found during rebuild");
    }
    
    TableInfo& tableInfo = it->second;
    
    // Проверяем есть ли специальный обработчик для этой таблицы
    auto handlerIt = rebuildHandlers.find(tag);
    if (handlerIt != rebuildHandlers.end()) {
        handlerIt->second(tag);
    } else {
        // Базовая обработка для таблиц без специальной логики
        if (!tableInfo.modified) {
            // Если таблица не модифицирована, используем оригинальные данные
            if (tableInfo.originalOffset + tableInfo.originalLength <= originalData.size()) {
                tableInfo.data.assign(originalData.begin() + tableInfo.originalOffset,
                                    originalData.begin() + tableInfo.originalOffset + tableInfo.originalLength);
            }
        }
        tableInfo.newLength = tableInfo.data.size();
    }
    
    std::cout << "TTFRebuilder: Rebuilt table '" << tag << "', size: " 
              << tableInfo.newLength << " bytes" << std::endl;
}

void TTFRebuilder::rebuildGlyfTable(const std::string& tag) {
    auto& tableInfo = tables[tag];
    
    validateGlyphData();
    calculateGlyphMetrics();
    
    std::cout << "TTFRebuilder: Processed glyf table with " 
              << glyphOffsets.size() << " glyphs, size: " 
              << tableInfo.data.size() << " bytes" << std::endl;
}

void TTFRebuilder::rebuildLocaTable(const std::string& tag) {
    auto& tableInfo = tables[tag];
    
    auto headIt = tables.find("head");
    if (headIt == tables.end()) {
        throw std::runtime_error("head table not found for loca table rebuild");
    }
    
    validateTableData("head", HEAD_TABLE_SIZE);
    const auto& headData = headIt->second.data;
    
    int16_t indexToLocFormat = getInt16(headData, 50);
    locaShortFormat = (indexToLocFormat == 0);
    
    calculateGlyphOffsets();
    
    std::vector<uint8_t> newLocaData;
    
    if (locaShortFormat) {
        newLocaData.resize((numGlyphs + 1) * 2);
        for (size_t i = 0; i <= numGlyphs; ++i) {
            uint32_t offset = (i < glyphOffsets.size()) ? glyphOffsets[i].offset / 2 : 0;
            if (offset > 0xFFFF) {
                locaShortFormat = false;
                setInt16(headIt->second.data, 50, 1);
                std::cout << "TTFRebuilder: Switching loca to long format due to offset overflow" << std::endl;
                rebuildLocaTable(tag);
                return;
            }
            setUInt16(newLocaData, i * 2, static_cast<uint16_t>(offset));
        }
    } else {
        newLocaData.resize((numGlyphs + 1) * 4);
        for (size_t i = 0; i <= numGlyphs; ++i) {
            uint32_t offset = (i < glyphOffsets.size()) ? glyphOffsets[i].offset : 0;
            setUInt32(newLocaData, i * 4, offset);
        }
    }
    
    tableInfo.data = newLocaData;
    tableInfo.newLength = newLocaData.size();
    
    std::cout << "TTFRebuilder: Rebuilt loca table with " << numGlyphs 
              << " glyphs, format: " << (locaShortFormat ? "short" : "long") 
              << ", size: " << tableInfo.newLength << " bytes" << std::endl;
}

void TTFRebuilder::rebuildHmtxTable(const std::string& tag) {
    auto& tableInfo = tables[tag];
    
    calculateHMetrics();
    
    std::vector<uint8_t> newHmtxData;
    newHmtxData.resize(numHMetrics * 4 + (numGlyphs - numHMetrics) * 2);
    
    for (uint16_t i = 0; i < numHMetrics; ++i) {
        if (i < glyphOffsets.size()) {
            setUInt16(newHmtxData, i * 4, glyphOffsets[i].advanceWidth);
            setInt16(newHmtxData, i * 4 + 2, glyphOffsets[i].leftSideBearing);
        } else {
            setUInt16(newHmtxData, i * 4, 500);
            setInt16(newHmtxData, i * 4 + 2, 0);
        }
    }
    
    // УДАЛЕНО: uint16_t lastAdvanceWidth = (numHMetrics > 0 && numHMetrics - 1 < glyphOffsets.size()) ...
    
    for (uint16_t i = numHMetrics; i < numGlyphs; ++i) {
        int16_t lsb = (i < glyphOffsets.size()) ? glyphOffsets[i].leftSideBearing : 0;
        setInt16(newHmtxData, numHMetrics * 4 + (i - numHMetrics) * 2, lsb);
    }
    
    tableInfo.data = newHmtxData;
    tableInfo.newLength = newHmtxData.size();
    
    std::cout << "TTFRebuilder: Rebuilt hmtx table with " << numGlyphs 
              << " glyphs, " << numHMetrics << " h-metrics, size: " 
              << tableInfo.newLength << " bytes" << std::endl;
}

void TTFRebuilder::rebuildHheaTable(const std::string& tag) {
    auto& tableInfo = tables[tag];
    validateTableData(tag, HHEA_TABLE_SIZE);
    
    setUInt16(tableInfo.data, 34, numHMetrics);
    updateHheaMetrics();
    
    std::cout << "TTFRebuilder: Updated hhea table, numberOfHMetrics: " 
              << numHMetrics << std::endl;
}

void TTFRebuilder::rebuildMaxpTable(const std::string& tag) {
    auto& tableInfo = tables[tag];
    validateTableData(tag, 6);
    
    setUInt16(tableInfo.data, 4, numGlyphs);
    updateMaxpTableValues();
    
    std::cout << "TTFRebuilder: Updated maxp table, numGlyphs: " 
              << numGlyphs << std::endl;
}

void TTFRebuilder::rebuildNameTable(const std::string& tag) {
    auto& tableInfo = tables[tag];
    
    if (tableInfo.modified) {
        updateNameTableChecksum();
    }
}

void TTFRebuilder::rebuildOS2Table(const std::string& tag) {
    auto& tableInfo = tables[tag];
    
    if (tableInfo.modified || tables["glyf"].modified || tables["hmtx"].modified) {
        validateTableData(tag, OS2_TABLE_SIZE);
        updateOS2Metrics();
        std::cout << "TTFRebuilder: Updated OS/2 table metrics" << std::endl;
    }
}

void TTFRebuilder::rebuildHeadTable(const std::string& tag) {
    auto& tableInfo = tables[tag];
    validateTableData(tag, HEAD_TABLE_SIZE);
    
    uint64_t currentTimestamp = (uint64_t)time(nullptr) + 2082844800;
    setUInt32(tableInfo.data, 4, (currentTimestamp >> 32) & 0xFFFFFFFF);
    setUInt32(tableInfo.data, 8, currentTimestamp & 0xFFFFFFFF);
    
    setUInt32(tableInfo.data, 12, HEAD_MAGIC);
    setInt16(tableInfo.data, 50, locaShortFormat ? 0 : 1);
    
    std::cout << "TTFRebuilder: Updated head table" << std::endl;
}

void TTFRebuilder::rebuildPostTable(const std::string& tag) {
    auto& tableInfo = tables[tag];
    
    if (tableInfo.modified) {
        updatePostTableFormat2();
    }
}

// УДАЛЕНО: Реализации без параметров - используем версии с параметрами по умолчанию
// void TTFRebuilder::updateGlyfTable() {
// void TTFRebuilder::updateLocaTable() {
// void TTFRebuilder::updateHmtxTable() {
// void TTFRebuilder::updateHheaTable() {
// void TTFRebuilder::updateMaxpTable() {

void TTFRebuilder::updateGlyfTable(const std::string& glyfTag) {
    if (tables.find(glyfTag) == tables.end() || !tables[glyfTag].modified) return;
    
    markTableModified("loca");
    markTableModified("maxp");
    markTableModified("hmtx");
    markTableModified("OS/2");
    
    calculateGlyphOffsets();
    calculateGlyphMetrics();
}

void TTFRebuilder::updateLocaTable(const std::string& locaTag) {
    if (tables.find(locaTag) == tables.end()) return;
    
    if (tables[locaTag].modified) {
        rebuildLocaTable(locaTag);
    }
}

void TTFRebuilder::updateHmtxTable(const std::string& hmtxTag) {
    if (tables.find(hmtxTag) == tables.end()) return;
    
    if (tables[hmtxTag].modified) {
        rebuildHmtxTable(hmtxTag);
        markTableModified("hhea");
    }
}

void TTFRebuilder::updateHheaTable(const std::string& hheaTag) {
    if (tables.find(hheaTag) == tables.end()) return;
    
    if (tables[hheaTag].modified) {
        rebuildHheaTable(hheaTag);
    }
}

void TTFRebuilder::updateMaxpTable(const std::string& maxpTag) {
    if (tables.find(maxpTag) == tables.end()) return;
    
    if (tables[maxpTag].modified) {
        rebuildMaxpTable(maxpTag);
    }
}

uint16_t TTFRebuilder::getUInt16(const std::vector<uint8_t>& data, size_t offset) const {
    if (offset + 2 > data.size()) {
        throw std::runtime_error("Read UInt16 beyond data boundary");
    }
    return (static_cast<uint16_t>(data[offset]) << 8) | data[offset + 1];
}

uint32_t TTFRebuilder::getUInt32(const std::vector<uint8_t>& data, size_t offset) const {
    if (offset + 4 > data.size()) {
        throw std::runtime_error("Read UInt32 beyond data boundary");
    }
    return (static_cast<uint32_t>(data[offset]) << 24) | 
           (static_cast<uint32_t>(data[offset + 1]) << 16) | 
           (static_cast<uint32_t>(data[offset + 2]) << 8) | 
           data[offset + 3];
}

int16_t TTFRebuilder::getInt16(const std::vector<uint8_t>& data, size_t offset) const {
    if (offset + 2 > data.size()) {
        throw std::runtime_error("Read Int16 beyond data boundary");
    }
    return (static_cast<int16_t>(data[offset]) << 8) | data[offset + 1];
}

void TTFRebuilder::setUInt16(std::vector<uint8_t>& data, size_t offset, uint16_t value) {
    if (offset + 2 > data.size()) {
        throw std::runtime_error("Write UInt16 beyond data boundary");
    }
    data[offset] = (value >> 8) & 0xFF;
    data[offset + 1] = value & 0xFF;
}

void TTFRebuilder::setUInt32(std::vector<uint8_t>& data, size_t offset, uint32_t value) {
    if (offset + 4 > data.size()) {
        throw std::runtime_error("Write UInt32 beyond data boundary");
    }
    data[offset] = (value >> 24) & 0xFF;
    data[offset + 1] = (value >> 16) & 0xFF;
    data[offset + 2] = (value >> 8) & 0xFF;
    data[offset + 3] = value & 0xFF;
}

void TTFRebuilder::setInt16(std::vector<uint8_t>& data, size_t offset, int16_t value) {
    if (offset + 2 > data.size()) {
        throw std::runtime_error("Write Int16 beyond data boundary");
    }
    data[offset] = (value >> 8) & 0xFF;
    data[offset + 1] = value & 0xFF;
}

void TTFRebuilder::calculateGlyphOffsets() {
    glyphOffsets.clear();
    
    auto glyfIt = tables.find("glyf");
    if (glyfIt == tables.end() || glyfIt->second.data.empty()) {
        for (uint16_t i = 0; i <= numGlyphs; ++i) {
            glyphOffsets.push_back({0, 0, 0, 0, true});
        }
        return;
    }
    
    const auto& glyfData = glyfIt->second.data;
    uint32_t currentOffset = 0;
    
    for (uint16_t i = 0; i < numGlyphs; ++i) {
        GlyphInfo glyph;
        glyph.offset = currentOffset;
        glyph.isEmpty = false;
        
        if (currentOffset >= glyfData.size()) {
            glyph.length = 0;
            glyph.isEmpty = true;
        } else {
            int16_t numberOfContours = getInt16(glyfData, currentOffset);
            
            if (numberOfContours >= 0) {
                glyph.length = parseSimpleGlyphLength(glyfData, currentOffset);
            } else {
                glyph.length = parseCompositeGlyphLength(glyfData, currentOffset);
            }
            
            if (currentOffset + glyph.length > glyfData.size()) {
                glyph.length = glyfData.size() - currentOffset;
                std::cerr << "TTFRebuilder: Glyph " << i << " length exceeds table bounds" << std::endl;
            }
        }
        
        glyphOffsets.push_back(glyph);
        currentOffset += glyph.length;
        
        if (currentOffset % 2 != 0 && currentOffset < glyfData.size()) {
            currentOffset++;
        }
    }
    
    glyphOffsets.push_back({currentOffset, 0, 0, 0, true});
    
    std::cout << "TTFRebuilder: Calculated " << glyphOffsets.size() 
              << " glyph offsets, total glyf size: " << currentOffset << " bytes" << std::endl;
}

uint32_t TTFRebuilder::parseSimpleGlyphLength(const std::vector<uint8_t>& data, uint32_t offset) const {
    if (offset + 12 > data.size()) return 0;
    
    int16_t numberOfContours = getInt16(data, offset);
    if (numberOfContours < 0) return 0;
    
    uint32_t length = 10 + 2 * numberOfContours;
    
    uint16_t instructionLength = getUInt16(data, offset + length);
    length += 2 + instructionLength;
    
    uint32_t currentPos = length;
    for (int16_t contour = 0; contour < numberOfContours; ++contour) {
        uint16_t pointsInContour = getUInt16(data, offset + 10 + contour * 2);
        
        for (uint16_t point = 0; point < pointsInContour; ++point) {
            if (currentPos >= data.size()) break;
            
            uint8_t flag = data[offset + currentPos];
            currentPos++;
            
            if (flag & 0x02) {
                currentPos += 1;
            } else if (!(flag & 0x10)) {
                currentPos += 2;
            }
            
            if (flag & 0x04) {
                currentPos += 1;
            } else if (!(flag & 0x20)) {
                currentPos += 2;
            }
        }
    }
    
    return currentPos;
}

uint32_t TTFRebuilder::parseCompositeGlyphLength(const std::vector<uint8_t>& data, uint32_t offset) const {
    if (offset + 10 > data.size()) return 0;
    
    uint32_t currentPos = 10;
    
    bool moreComponents = true;
    while (moreComponents && currentPos < data.size()) {
        uint16_t flags = getUInt16(data, offset + currentPos);
        currentPos += 2;
        
        // УДАЛЕНО: uint16_t glyphIndex = getUInt16(data, offset + currentPos);
        getUInt16(data, offset + currentPos); // Просто читаем, но не используем
        currentPos += 2;
        
        if (flags & 0x0001) {
            currentPos += 4;
        } else {
            currentPos += 2;
        }
        
        if (flags & 0x0008) {
            currentPos += 2;
        } else if (flags & 0x0040) {
            currentPos += 4;
        } else if (flags & 0x0080) {
            currentPos += 8;
        }
        
        moreComponents = (flags & 0x0020);
    }
    
    return currentPos;
}

void TTFRebuilder::calculateGlyphMetrics() {
    auto glyfIt = tables.find("glyf");
    if (glyfIt == tables.end()) return;
    
    const auto& glyfData = glyfIt->second.data;
    
    for (size_t i = 0; i < glyphOffsets.size() && i < numGlyphs; ++i) {
        auto& glyph = glyphOffsets[i];
        
        if (glyph.isEmpty || glyph.offset >= glyfData.size()) {
            auto hmtxIt = tables.find("hmtx");
            if (hmtxIt != tables.end() && i < numHMetrics) {
                const auto& hmtxData = hmtxIt->second.data;
                if (hmtxData.size() >= (i * 4 + 4)) {
                    glyph.advanceWidth = getUInt16(hmtxData, i * 4);
                    glyph.leftSideBearing = getInt16(hmtxData, i * 4 + 2);
                } else {
                    glyph.advanceWidth = 500;
                    glyph.leftSideBearing = 0;
                }
            } else {
                glyph.advanceWidth = 500;
                glyph.leftSideBearing = 0;
            }
            continue;
        }
        
        int16_t numberOfContours = getInt16(glyfData, glyph.offset);
        
        if (numberOfContours == 0) {
            glyph.advanceWidth = 500;
            glyph.leftSideBearing = 0;
        } else {
            int16_t xMin = getInt16(glyfData, glyph.offset + 2);
            // УДАЛЕНО: int16_t yMin = getInt16(glyfData, glyph.offset + 4);
            getInt16(glyfData, glyph.offset + 4); // Просто читаем yMin
            int16_t xMax = getInt16(glyfData, glyph.offset + 6);
            // УДАЛЕНО: int16_t yMax = getInt16(glyfData, glyph.offset + 8);
            getInt16(glyfData, glyph.offset + 8); // Просто читаем yMax
            
            int16_t glyphWidth = xMax - xMin;
            glyph.advanceWidth = std::max(static_cast<uint16_t>(glyphWidth + 50), static_cast<uint16_t>(500));
            glyph.leftSideBearing = xMin;
        }
    }
    
    std::cout << "TTFRebuilder: Calculated metrics for " << glyphOffsets.size() << " glyphs" << std::endl;
}

void TTFRebuilder::calculateHMetrics() {
    std::map<uint16_t, uint32_t> advanceWidthCounts;
    std::set<uint16_t> uniqueAdvanceWidths;
    
    for (const auto& glyph : glyphOffsets) {
        if (!glyph.isEmpty) {
            advanceWidthCounts[glyph.advanceWidth]++;
            uniqueAdvanceWidths.insert(glyph.advanceWidth);
        }
    }
    
    uint16_t optimalHMetrics = numGlyphs;
    uint32_t threshold = numGlyphs / 10;
    
    for (uint16_t i = 0; i < numGlyphs; ++i) {
        if (i >= glyphOffsets.size()) break;
        
        uint16_t currentWidth = glyphOffsets[i].advanceWidth;
        uint32_t count = advanceWidthCounts[currentWidth];
        
        if (count < threshold && i > numGlyphs / 3) {
            optimalHMetrics = i + 1;
            break;
        }
    }
    
    numHMetrics = std::min(optimalHMetrics, numGlyphs);
    // ИСПРАВЛЕНО: убрана лишняя проверка, так как numHMetrics всегда <= numGlyphs <= 0xFFFF
    // if (numHMetrics > 0xFFFF) {
    //     numHMetrics = 0xFFFF;
    // }
    
    std::cout << "TTFRebuilder: Optimized h-metrics: " << numHMetrics 
              << " (unique advance widths: " << uniqueAdvanceWidths.size() << ")" << std::endl;
}

void TTFRebuilder::setNumGlyphs(uint16_t newNumGlyphs) {
    if (newNumGlyphs != numGlyphs) {
        numGlyphs = newNumGlyphs;
        markTableModified("maxp");
        markTableModified("loca");
        markTableModified("hmtx");
        std::cout << "TTFRebuilder: Set numGlyphs to " << numGlyphs << std::endl;
    }
}

void TTFRebuilder::setNumberOfHMetrics(uint16_t newNumHMetrics) {
    if (newNumHMetrics != numHMetrics) {
        numHMetrics = newNumHMetrics;
        markTableModified("hhea");
        markTableModified("hmtx");
        std::cout << "TTFRebuilder: Set numberOfHMetrics to " << numHMetrics << std::endl;
    }
}

bool TTFRebuilder::parseLocaTable() {
    auto locaIt = tables.find("loca");
    if (locaIt == tables.end()) return false;
    return true;
}

bool TTFRebuilder::parseMaxpTable() {
    auto maxpIt = tables.find("maxp");
    if (maxpIt == tables.end()) return false;
    
    const auto& maxpData = maxpIt->second.data;
    if (maxpData.size() < 6) return false;
    
    numGlyphs = getUInt16(maxpData, 4);
    return true;
}

bool TTFRebuilder::parseHheaTable() {
    auto hheaIt = tables.find("hhea");
    if (hheaIt == tables.end()) return false;
    
    const auto& hheaData = hheaIt->second.data;
    if (hheaData.size() < 36) return false;
    
    numHMetrics = getUInt16(hheaData, 34);
    return true;
}

bool TTFRebuilder::parseHeadTable() {
    auto headIt = tables.find("head");
    if (headIt == tables.end()) return false;
    
    const auto& headData = headIt->second.data;
    if (headData.size() < HEAD_TABLE_SIZE) return false;
    
    uint32_t magic = getUInt32(headData, 12);
    if (magic != HEAD_MAGIC) {
        std::cerr << "TTFRebuilder: Warning - head table magic number incorrect" << std::endl;
    }
    
    int16_t indexToLocFormat = getInt16(headData, 50);
    locaShortFormat = (indexToLocFormat == 0);
    
    return true;
}

void TTFRebuilder::parseGlyfTable() {
    auto glyfIt = tables.find("glyf");
    if (glyfIt == tables.end()) return;
    calculateGlyphOffsets();
}

void TTFRebuilder::recalculateFontMetrics() {
    updateHheaMetrics();
    updateOS2Metrics();
}

void TTFRebuilder::updateHheaMetrics() {
    auto hheaIt = tables.find("hhea");
    if (hheaIt == tables.end()) return;
    
    int16_t ascender = -10000;
    int16_t descender = 10000;
    int16_t lineGap = 200;
    uint16_t maxAdvance = 0;
    int16_t minLeftSideBearing = 0;
    int16_t maxRightSideBearing = 0;
    
    for (const auto& glyph : glyphOffsets) {
        if (glyph.isEmpty) continue;
        
        auto os2It = tables.find("OS/2");
        if (os2It != tables.end() && os2It->second.data.size() >= 10) {
            ascender = std::max(ascender, getInt16(os2It->second.data, 68));
            descender = std::min(descender, getInt16(os2It->second.data, 70));
        }
        
        maxAdvance = std::max(maxAdvance, glyph.advanceWidth);
        
        int16_t rightSideBearing = glyph.advanceWidth - glyph.leftSideBearing;
        minLeftSideBearing = std::min(minLeftSideBearing, glyph.leftSideBearing);
        maxRightSideBearing = std::max(maxRightSideBearing, rightSideBearing);
    }
    
    setInt16(hheaIt->second.data, 4, ascender);
    setInt16(hheaIt->second.data, 6, descender);
    setInt16(hheaIt->second.data, 8, lineGap);
    setUInt16(hheaIt->second.data, 10, maxAdvance);
    setInt16(hheaIt->second.data, 12, minLeftSideBearing);
    setInt16(hheaIt->second.data, 14, maxRightSideBearing);
}

void TTFRebuilder::updateOS2Metrics() {
    auto os2It = tables.find("OS/2");
    if (os2It == tables.end()) return;
    
    uint32_t totalWidth = 0;
    uint32_t count = 0;
    for (const auto& glyph : glyphOffsets) {
        if (!glyph.isEmpty) {
            totalWidth += glyph.advanceWidth;
            count++;
        }
    }
    uint16_t avgWidth = count > 0 ? totalWidth / count : 500;
    setInt16(os2It->second.data, 2, static_cast<int16_t>(avgWidth));
    
    auto hheaIt = tables.find("hhea");
    if (hheaIt != tables.end() && hheaIt->second.data.size() >= 16) {
        int16_t ascender = getInt16(hheaIt->second.data, 4);
        int16_t descender = getInt16(hheaIt->second.data, 6);
        
        setInt16(os2It->second.data, 68, ascender);
        setInt16(os2It->second.data, 70, descender);
        setInt16(os2It->second.data, 72, getInt16(hheaIt->second.data, 8));
    }
}

void TTFRebuilder::updateMaxpTableValues() {
    auto maxpIt = tables.find("maxp");
    if (maxpIt == tables.end()) return;
    
    uint16_t maxPoints = 0;
    uint16_t maxContours = 0;
    uint16_t maxCompositePoints = 0;
    uint16_t maxCompositeContours = 0;
    uint16_t maxSizeOfInstructions = 0;
    uint16_t maxComponentElements = 0;
    uint16_t maxComponentDepth = 0;
    
    auto glyfIt = tables.find("glyf");
    if (glyfIt != tables.end()) {
        const auto& glyfData = glyfIt->second.data;
        
        for (const auto& glyph : glyphOffsets) {
            if (glyph.isEmpty || glyph.offset >= glyfData.size()) continue;
            
            int16_t numberOfContours = getInt16(glyfData, glyph.offset);
            
            if (numberOfContours >= 0) {
                maxContours = std::max(maxContours, static_cast<uint16_t>(numberOfContours));
                
                uint16_t points = calculateSimpleGlyphPoints(glyfData, glyph.offset);
                maxPoints = std::max(maxPoints, points);
                
                uint16_t instructionLength = getUInt16(glyfData, glyph.offset + 10 + 2 * numberOfContours);
                maxSizeOfInstructions = std::max(maxSizeOfInstructions, instructionLength);
                
            } else {
                auto compositeStats = calculateCompositeGlyphStats(glyfData, glyph.offset);
                maxCompositePoints = std::max(maxCompositePoints, compositeStats.maxPoints);
                maxCompositeContours = std::max(maxCompositeContours, compositeStats.maxContours);
                maxComponentElements = std::max(maxComponentElements, compositeStats.maxComponents);
                maxComponentDepth = std::max(maxComponentDepth, compositeStats.maxDepth);
            }
        }
    }
    
    if (maxpIt->second.data.size() >= 32) {
        setUInt16(maxpIt->second.data, 6, maxPoints);
        setUInt16(maxpIt->second.data, 8, maxContours);
        setUInt16(maxpIt->second.data, 10, maxCompositePoints);
        setUInt16(maxpIt->second.data, 12, maxCompositeContours);
        setUInt16(maxpIt->second.data, 14, maxSizeOfInstructions);
        setUInt16(maxpIt->second.data, 16, maxComponentElements);
        setUInt16(maxpIt->second.data, 18, maxComponentDepth);
    }
}

uint16_t TTFRebuilder::calculateSimpleGlyphPoints(const std::vector<uint8_t>& data, uint32_t offset) const {
    if (offset + 12 > data.size()) return 0;
    
    int16_t numberOfContours = getInt16(data, offset);
    if (numberOfContours <= 0) return 0;
    
    uint16_t totalPoints = 0;
    for (int16_t i = 0; i < numberOfContours; ++i) {
        if (offset + 10 + (i + 1) * 2 > data.size()) break;
        uint16_t pointsInContour = getUInt16(data, offset + 10 + i * 2);
        totalPoints += pointsInContour;
    }
    
    return totalPoints;
}

TTFRebuilder::CompositeGlyphStats TTFRebuilder::calculateCompositeGlyphStats(const std::vector<uint8_t>& data, uint32_t offset) const {
    CompositeGlyphStats stats = {0, 0, 0, 0};
    
    if (offset + 10 > data.size()) return stats;
    
    uint32_t currentPos = 10;
    uint16_t componentCount = 0;
    
    bool moreComponents = true;
    while (moreComponents && currentPos < data.size()) {
        componentCount++;
        stats.maxComponents = componentCount;
        
        uint16_t flags = getUInt16(data, offset + currentPos);
        currentPos += 2;
        
        uint16_t glyphIndex = getUInt16(data, offset + currentPos);
        currentPos += 2;
        
        if (glyphIndex < glyphOffsets.size() && !glyphOffsets[glyphIndex].isEmpty) {
            auto componentStats = analyzeGlyphForComposite(data, glyphOffsets[glyphIndex].offset);
            stats.maxPoints = std::max(stats.maxPoints, componentStats.maxPoints);
            stats.maxContours = std::max(stats.maxContours, componentStats.maxContours);
            stats.maxDepth = std::max(stats.maxDepth, static_cast<uint16_t>(componentStats.maxDepth + 1));
        }
        
        if (flags & 0x0001) {
            currentPos += 4;
        } else {
            currentPos += 2;
        }
        
        if (flags & 0x0008) {
            currentPos += 2;
        } else if (flags & 0x0040) {
            currentPos += 4;
        } else if (flags & 0x0080) {
            currentPos += 8;
        }
        
        moreComponents = (flags & 0x0020);
    }
    
    return stats;
}

TTFRebuilder::CompositeGlyphStats TTFRebuilder::analyzeGlyphForComposite(const std::vector<uint8_t>& data, uint32_t offset) const {
    CompositeGlyphStats stats = {0, 0, 0, 0};
    
    if (offset >= data.size()) return stats;
    
    int16_t numberOfContours = getInt16(data, offset);
    
    if (numberOfContours >= 0) {
        stats.maxContours = std::max(stats.maxContours, static_cast<uint16_t>(numberOfContours));
        stats.maxPoints = calculateSimpleGlyphPoints(data, offset);
    } else {
        stats = calculateCompositeGlyphStats(data, offset);
        stats.maxDepth++;
    }
    
    return stats;
}

void TTFRebuilder::updateNameTableChecksum() {
    auto nameIt = tables.find("name");
    if (nameIt == tables.end()) return;
    
    auto& nameData = nameIt->second.data;
    if (nameData.size() < 6) {
        throw std::runtime_error("name table too small");
    }
    
    uint16_t format = getUInt16(nameData, 0);
    uint16_t count = getUInt16(nameData, 2);
    uint16_t stringOffset = getUInt16(nameData, 4);
    
    size_t expectedSize = 6 + count * 12;
    if (nameData.size() < expectedSize) {
        throw std::runtime_error("name table structure corrupted");
    }
    
    std::vector<uint8_t> newNameData;
    std::vector<uint8_t> stringStorage;
    std::vector<NameRecord> nameRecords;
    
    for (uint16_t i = 0; i < count; ++i) {
        size_t recordOffset = 6 + i * 12;
        NameRecord record;
        record.platformID = getUInt16(nameData, recordOffset);
        record.encodingID = getUInt16(nameData, recordOffset + 2);
        record.languageID = getUInt16(nameData, recordOffset + 4);
        record.nameID = getUInt16(nameData, recordOffset + 6);
        record.length = getUInt16(nameData, recordOffset + 8);
        record.offset = getUInt16(nameData, recordOffset + 10);
        
        // ИСПРАВЛЕНО: приведение типов для сравнения
        if (static_cast<size_t>(stringOffset + record.offset + record.length) > nameData.size()) {
            std::cerr << "TTFRebuilder: Fixing invalid string offset in name record " << i << std::endl;
            record.offset = static_cast<uint16_t>(stringStorage.size());
        }
        
        size_t stringStart = stringOffset + record.offset;
        if (stringStart + record.length <= nameData.size()) {
            std::vector<uint8_t> stringData(
                nameData.begin() + stringStart,
                nameData.begin() + stringStart + record.length
            );
            
            if (record.platformID == 1 && record.encodingID == 0) {
                fixMacRomanEncoding(stringData);
            } else if (record.platformID == 3 && record.encodingID == 1) {
                fixUnicodeEncoding(stringData);
            }
            
            record.offset = static_cast<uint16_t>(stringStorage.size());
            record.length = static_cast<uint16_t>(stringData.size());
            
            stringStorage.insert(stringStorage.end(), stringData.begin(), stringData.end());
        } else {
            record.offset = static_cast<uint16_t>(stringStorage.size());
            record.length = 0;
        }
        
        nameRecords.push_back(record);
    }
    
    if (stringStorage.size() % 2 != 0) {
        stringStorage.push_back(0);
    }
    
    newNameData.resize(6 + nameRecords.size() * 12 + stringStorage.size());
    
    setUInt16(newNameData, 0, format);
    setUInt16(newNameData, 2, static_cast<uint16_t>(nameRecords.size()));
    setUInt16(newNameData, 4, 6 + static_cast<uint16_t>(nameRecords.size() * 12));
    
    for (size_t i = 0; i < nameRecords.size(); ++i) {
        size_t recordOffset = 6 + i * 12;
        const auto& record = nameRecords[i];
        
        setUInt16(newNameData, recordOffset, record.platformID);
        setUInt16(newNameData, recordOffset + 2, record.encodingID);
        setUInt16(newNameData, recordOffset + 4, record.languageID);
        setUInt16(newNameData, recordOffset + 6, record.nameID);
        setUInt16(newNameData, recordOffset + 8, record.length);
        setUInt16(newNameData, recordOffset + 10, record.offset);
    }
    
    std::copy(stringStorage.begin(), stringStorage.end(), 
              newNameData.begin() + 6 + nameRecords.size() * 12);
    
    nameIt->second.data = newNameData;
    nameIt->second.newLength = newNameData.size();
    
    std::cout << "TTFRebuilder: Rebuilt name table with " << nameRecords.size() 
              << " records, string storage: " << stringStorage.size() << " bytes" << std::endl;
}

void TTFRebuilder::updatePostTableFormat2() {
    auto postIt = tables.find("post");
    if (postIt == tables.end()) return;
    
    auto& postData = postIt->second.data;
    if (postData.size() < 32) {
        throw std::runtime_error("post table too small");
    }
    
    uint32_t format = getUInt32(postData, 0);
    if (format != 0x00020000) {
        return;
    }
    
    uint32_t italicAngle = getUInt32(postData, 4);
    int16_t underlinePosition = getInt16(postData, 8);
    int16_t underlineThickness = getInt16(postData, 10);
    uint32_t isFixedPitch = getUInt32(postData, 12);
    uint32_t minMemType42 = getUInt32(postData, 16);
    uint32_t maxMemType42 = getUInt32(postData, 20);
    uint32_t minMemType1 = getUInt32(postData, 24);
    uint32_t maxMemType1 = getUInt32(postData, 28);
    
    uint16_t numberOfGlyphs = getUInt16(postData, 32);
    
    if (numberOfGlyphs != numGlyphs) {
        std::cout << "TTFRebuilder: Updating post table glyph count from " 
                  << numberOfGlyphs << " to " << numGlyphs << std::endl;
    }
    
    std::vector<uint8_t> newPostData;
    // ИСПРАВЛЕНО: приведение типов для сравнения
    size_t newSize = 34 + numGlyphs * 2;
    newPostData.resize(newSize);
    
    setUInt32(newPostData, 0, format);
    setUInt32(newPostData, 4, italicAngle);
    setInt16(newPostData, 8, underlinePosition);
    setInt16(newPostData, 10, underlineThickness);
    setUInt32(newPostData, 12, isFixedPitch);
    setUInt32(newPostData, 16, minMemType42);
    setUInt32(newPostData, 20, maxMemType42);
    setUInt32(newPostData, 24, minMemType1);
    setUInt32(newPostData, 28, maxMemType1);
    setUInt16(newPostData, 32, numGlyphs);
    
    // ИСПРАВЛЕНО: приведение типов для сравнения
    if (postData.size() >= static_cast<size_t>(34 + numberOfGlyphs * 2)) {
        for (uint16_t i = 0; i < numGlyphs; ++i) {
            if (i < numberOfGlyphs) {
                uint16_t nameIndex = getUInt16(postData, 34 + i * 2);
                setUInt16(newPostData, 34 + i * 2, nameIndex);
            } else {
                setUInt16(newPostData, 34 + i * 2, calculateStandardGlyphNameIndex(i));
            }
        }
    } else {
        for (uint16_t i = 0; i < numGlyphs; ++i) {
            setUInt16(newPostData, 34 + i * 2, calculateStandardGlyphNameIndex(i));
        }
    }
    
    postIt->second.data = newPostData;
    postIt->second.newLength = newPostData.size();
    
    std::cout << "TTFRebuilder: Rebuilt post table format 2.0 with " 
              << numGlyphs << " glyph name indexes" << std::endl;
}

void TTFRebuilder::fixMacRomanEncoding(std::vector<uint8_t>& stringData) {
    for (auto& byte : stringData) {
        if (byte >= 0x80 && byte <= 0x9F) {
            byte = '?';
        }
    }
    
    if (stringData.empty() || stringData.back() != 0) {
        stringData.push_back(0);
    }
}

void TTFRebuilder::fixUnicodeEncoding(std::vector<uint8_t>& stringData) {
    if (stringData.size() % 2 != 0) {
        stringData.push_back(0);
    }
    
    if (stringData.size() >= 2) {
        uint16_t bom = (static_cast<uint16_t>(stringData[0]) << 8) | stringData[1];
        if (bom != 0xFEFF && bom != 0xFFFE) {
            std::vector<uint8_t> newStringData = {0xFE, 0xFF};
            newStringData.insert(newStringData.end(), stringData.begin(), stringData.end());
            stringData = newStringData;
        }
    }
    
    for (size_t i = 0; i + 1 < stringData.size(); i += 2) {
        uint16_t codePoint = (static_cast<uint16_t>(stringData[i]) << 8) | stringData[i + 1];
        
        if ((codePoint >= 0xD800 && codePoint <= 0xDFFF) ||
            (codePoint >= 0xFDD0 && codePoint <= 0xFDEF) ||
            codePoint == 0xFFFE || codePoint == 0xFFFF) {
            stringData[i] = 0xFF;
            stringData[i + 1] = 0xFD;
        }
    }
}

uint16_t TTFRebuilder::calculateStandardGlyphNameIndex(uint16_t glyphIndex) {
    if (glyphIndex < 258) {
        return glyphIndex;
    }
    
    uint16_t unicodeValue = getUnicodeFromCmap(glyphIndex);
    if (unicodeValue != 0xFFFF) {
        return generateUnicodeGlyphNameIndex(unicodeValue);
    }
    
    if (isCompositeGlyph(glyphIndex)) {
        return generateCompositeGlyphName(glyphIndex);
    }
    
    return generateDefaultGlyphName(glyphIndex);
}

uint16_t TTFRebuilder::getUnicodeFromCmap(uint16_t glyphIndex) {
    auto cmapIt = tables.find("cmap");
    if (cmapIt == tables.end()) return 0xFFFF;
    
    const auto& cmapData = cmapIt->second.data;
    if (cmapData.size() < 4) return 0xFFFF;
    
    // УДАЛЕНО: uint16_t version = getUInt16(cmapData, 0);
    getUInt16(cmapData, 0); // Просто читаем version
    uint16_t numTables = getUInt16(cmapData, 2);
    
    for (uint16_t i = 0; i < numTables; ++i) {
        size_t tableOffset = 4 + i * 8;
        if (tableOffset + 8 > cmapData.size()) break;
        
        uint16_t platformID = getUInt16(cmapData, tableOffset);
        uint16_t encodingID = getUInt16(cmapData, tableOffset + 2);
        uint32_t subtableOffset = getUInt32(cmapData, tableOffset + 4);
        
        if ((platformID == 0) ||
            (platformID == 3 && encodingID == 1) ||
            (platformID == 3 && encodingID == 10)) {
            uint32_t offset = subtableOffset;
            if (offset >= cmapData.size()) continue;
            
            uint16_t format = getUInt16(cmapData, offset);
            
            if (format == 4) {
                return findGlyphInFormat4Subtable(cmapData, offset, glyphIndex);
            } else if (format == 12) {
                return findGlyphInFormat12Subtable(cmapData, offset, glyphIndex);
            }
        }
    }
    
    return 0xFFFF;
}

uint16_t TTFRebuilder::findGlyphInFormat4Subtable(const std::vector<uint8_t>& cmapData, uint32_t offset, uint16_t glyphIndex) {
    if (offset + 14 > cmapData.size()) return 0xFFFF;
    
    // УДАЛЕНО: uint16_t length = getUInt16(cmapData, offset + 2);
    getUInt16(cmapData, offset + 2); // Просто читаем length
    // УДАЛЕНО: uint16_t language = getUInt16(cmapData, offset + 4);
    getUInt16(cmapData, offset + 4); // Просто читаем language
    uint16_t segCountX2 = getUInt16(cmapData, offset + 6);
    uint16_t segCount = segCountX2 / 2;
    
    uint32_t endCountOffset = offset + 14;
    uint32_t startCountOffset = endCountOffset + segCountX2 + 2;
    uint32_t idDeltaOffset = startCountOffset + segCountX2;
    uint32_t idRangeOffsetOffset = idDeltaOffset + segCountX2;
    // УДАЛЕНО: uint32_t glyphIdArrayOffset = idRangeOffsetOffset + segCountX2;
    
    for (uint16_t i = 0; i < segCount; ++i) {
        uint16_t endCount = getUInt16(cmapData, endCountOffset + i * 2);
        uint16_t startCount = getUInt16(cmapData, startCountOffset + i * 2);
        int16_t idDelta = getInt16(cmapData, idDeltaOffset + i * 2);
        uint16_t idRangeOffset = getUInt16(cmapData, idRangeOffsetOffset + i * 2);
        
        if (glyphIndex >= startCount && glyphIndex <= endCount) {
            if (idRangeOffset == 0) {
                return (glyphIndex + idDelta) & 0xFFFF;
            } else {
                uint32_t glyphOffset = idRangeOffsetOffset + i * 2 + idRangeOffset + 
                                     (glyphIndex - startCount) * 2;
                if (glyphOffset + 2 <= cmapData.size()) {
                    uint16_t glyphId = getUInt16(cmapData, glyphOffset);
                    if (glyphId != 0) {
                        return (glyphId + idDelta) & 0xFFFF;
                    }
                }
            }
        }
    }
    
    return 0xFFFF;
}

uint16_t TTFRebuilder::findGlyphInFormat12Subtable(const std::vector<uint8_t>& cmapData, uint32_t offset, uint16_t glyphIndex) {
    if (offset + 16 > cmapData.size()) return 0xFFFF;
    
    uint16_t format = getUInt16(cmapData, offset);
    if (format != 12) return 0xFFFF;
    
    // УДАЛЕНО: uint32_t length = getUInt32(cmapData, offset + 4);
    getUInt32(cmapData, offset + 4); // Просто читаем length
    // УДАЛЕНО: uint32_t language = getUInt32(cmapData, offset + 8);
    getUInt32(cmapData, offset + 8); // Просто читаем language
    uint32_t numGroups = getUInt32(cmapData, offset + 12);
    
    uint32_t groupsOffset = offset + 16;
    
    for (uint32_t i = 0; i < numGroups; ++i) {
        uint32_t groupOffset = groupsOffset + i * 12;
        if (groupOffset + 12 > cmapData.size()) break;
        
        uint32_t startCharCode = getUInt32(cmapData, groupOffset);
        uint32_t endCharCode = getUInt32(cmapData, groupOffset + 4);
        uint32_t startGlyphID = getUInt32(cmapData, groupOffset + 8);
        
        if (glyphIndex >= startGlyphID && glyphIndex <= startGlyphID + (endCharCode - startCharCode)) {
            uint32_t charCode = startCharCode + (glyphIndex - startGlyphID);
            return static_cast<uint16_t>(charCode & 0xFFFF);
        }
    }
    
    return 0xFFFF;
}

bool TTFRebuilder::isCompositeGlyph(uint16_t glyphIndex) {
    auto glyfIt = tables.find("glyf");
    if (glyfIt == tables.end()) return false;
    
    if (glyphIndex >= glyphOffsets.size()) return false;
    
    const auto& glyph = glyphOffsets[glyphIndex];
    if (glyph.isEmpty || glyph.offset >= glyfIt->second.data.size()) return false;
    
    int16_t numberOfContours = getInt16(glyfIt->second.data, glyph.offset);
    return numberOfContours < 0;
}

uint16_t TTFRebuilder::generateUnicodeGlyphNameIndex(uint16_t unicodeValue) {
    // Стандартные имена для часто используемых Unicode символов
    static const std::map<uint16_t, uint16_t> unicodeToNameIndex = {
        {0x0020, 258}, {0x00A0, 258}, {0x2000, 258}, {0x2001, 259}, {0x2002, 259},
        {0x2003, 259}, {0x2004, 260}, {0x2005, 260}, {0x2006, 260}, {0x2007, 261},
        {0x2008, 261}, {0x2009, 262}, {0x200A, 262}, {0x2010, 263}, {0x2011, 263},
        {0x2012, 264}, {0x2013, 264}, {0x2014, 265}, {0x2015, 265}, {0x2017, 266},
        {0x2018, 267}, {0x2019, 267}, {0x201A, 268}, {0x201B, 268}, {0x201C, 269},
        {0x201D, 269}, {0x201E, 270}, {0x201F, 270}, {0x2020, 271}, {0x2021, 272},
        {0x2022, 273}, {0x2023, 273}, {0x2024, 274}, {0x2025, 275}, {0x2026, 276},
        {0x2030, 277}, {0x2032, 278}, {0x2033, 279}, {0x2039, 280}, {0x203A, 281},
        {0x203C, 282}, {0x2044, 283}, {0x2070, 284}, {0x2074, 285}, {0x2075, 286},
        {0x2076, 287}, {0x2077, 288}, {0x2078, 289}, {0x2079, 290}, {0x207A, 291},
        {0x207B, 292}, {0x207C, 293}, {0x207D, 294}, {0x207E, 295}, {0x2080, 296},
        {0x2081, 297}, {0x2082, 298}, {0x2083, 299}, {0x2084, 300}, {0x2085, 301},
        {0x2086, 302}, {0x2087, 303}, {0x2088, 304}, {0x2089, 305}, {0x20A0, 306},
        {0x20A1, 307}, {0x20A2, 308}, {0x20A3, 309}, {0x20A4, 310}, {0x20A5, 311},
        {0x20A6, 312}, {0x20A7, 313}, {0x20A8, 314}, {0x20A9, 315}, {0x20AA, 316},
        {0x20AB, 317}, {0x20AC, 318}, {0x20AD, 319}, {0x20AE, 320}, {0x20AF, 321},
        {0x20B0, 322}, {0x20B1, 323}, {0x2100, 324}, {0x2101, 325}, {0x2102, 326},
        {0x2103, 327}, {0x2105, 328}, {0x2106, 329}, {0x2107, 330}, {0x2108, 331},
        {0x2109, 332}, {0x210A, 333}, {0x210B, 334}, {0x210C, 335}, {0x210D, 336},
        {0x210E, 337}, {0x210F, 338}, {0x2110, 339}, {0x2111, 340}, {0x2112, 341},
        {0x2113, 342}, {0x2115, 343}, {0x2116, 344}, {0x2117, 345}, {0x2118, 346},
        {0x2119, 347}, {0x211A, 348}, {0x211B, 349}, {0x211C, 350}, {0x211D, 351},
        {0x2120, 352}, {0x2122, 353}, {0x2124, 354}, {0x2126, 355}, {0x2128, 356},
        {0x212A, 357}, {0x212B, 358}, {0x212C, 359}, {0x212D, 360}, {0x212F, 361},
        {0x2130, 362}, {0x2131, 363}, {0x2133, 364}, {0x2134, 365}, {0x2135, 366},
        {0x2136, 367}, {0x2137, 368}, {0x2138, 369}, {0x2153, 370}, {0x2154, 371},
        {0x2155, 372}, {0x2156, 373}, {0x2157, 374}, {0x2158, 375}, {0x2159, 376},
        {0x215A, 377}, {0x215B, 378}, {0x215C, 379}, {0x215D, 380}, {0x215E, 381},
        {0x2190, 382}, {0x2191, 383}, {0x2192, 384}, {0x2193, 385}, {0x2194, 386},
        {0x2195, 387}, {0x21A8, 388}, {0x2200, 389}, {0x2202, 390}, {0x2203, 391},
        {0x2205, 392}, {0x2206, 393}, {0x2207, 394}, {0x2208, 395}, {0x2209, 396},
        {0x220B, 397}, {0x220F, 398}, {0x2211, 399}, {0x2212, 400}, {0x2217, 401},
        {0x221A, 402}, {0x221D, 403}, {0x221E, 404}, {0x221F, 405}, {0x2220, 406},
        {0x2227, 407}, {0x2228, 408}, {0x2229, 409}, {0x222A, 410}, {0x222B, 411},
        {0x2234, 412}, {0x223C, 413}, {0x2245, 414}, {0x2248, 415}, {0x2260, 416},
        {0x2261, 417}, {0x2264, 418}, {0x2265, 419}, {0x2282, 420}, {0x2283, 421},
        {0x2284, 422}, {0x2285, 423}, {0x2286, 424}, {0x2287, 425}, {0x2295, 426},
        {0x2297, 427}, {0x22A5, 428}, {0x22C5, 429}, {0x2302, 430}, {0x2310, 431},
        {0x2320, 432}, {0x2321, 433}, {0x2329, 434}, {0x232A, 435}, {0x2500, 436},
        {0x2502, 437}, {0x250C, 438}, {0x2510, 439}, {0x2514, 440}, {0x2518, 441},
        {0x251C, 442}, {0x2524, 443}, {0x252C, 444}, {0x2534, 445}, {0x253C, 446},
        {0x2550, 447}, {0x2551, 448}, {0x2552, 449}, {0x2553, 450}, {0x2554, 451},
        {0x2555, 452}, {0x2556, 453}, {0x2557, 454}, {0x2558, 455}, {0x2559, 456},
        {0x255A, 457}, {0x255B, 458}, {0x255C, 459}, {0x255D, 460}, {0x255E, 461},
        {0x255F, 462}, {0x2560, 463}, {0x2561, 464}, {0x2562, 465}, {0x2563, 466},
        {0x2564, 467}, {0x2565, 468}, {0x2566, 469}, {0x2567, 470}, {0x2568, 471},
        {0x2569, 472}, {0x256A, 473}, {0x256B, 474}, {0x256C, 475}, {0x2580, 476},
        {0x2584, 477}, {0x2588, 478}, {0x258C, 479}, {0x2590, 480}, {0x2591, 481},
        {0x2592, 482}, {0x2593, 483}, {0x25A0, 484}, {0x25A1, 485}, {0x25AA, 486},
        {0x25AB, 487}, {0x25AC, 488}, {0x25B2, 489}, {0x25BA, 490}, {0x25BC, 491},
        {0x25C4, 492}, {0x25CA, 493}, {0x25CB, 494}, {0x25CF, 495}, {0x25D8, 496},
        {0x25D9, 497}, {0x25E6, 498}, {0x263A, 499}, {0x263B, 500}, {0x263C, 501},
        {0x2640, 502}, {0x2642, 503}, {0x2660, 504}, {0x2663, 505}, {0x2665, 506},
        {0x2666, 507}, {0x266A, 508}, {0x266B, 509}, {0xF6BE, 510}, {0xF6BF, 511},
        {0xF6C0, 512}, {0xF6C1, 513}, {0xF6C2, 514}, {0xF6C3, 515}, {0xF6C4, 516},
        {0xF6C5, 517}, {0xF6C6, 518}, {0xF6C7, 519}, {0xF6C8, 520}, {0xF6C9, 521},
        {0xF6CA, 522}, {0xF6CB, 523}, {0xF6CC, 524}, {0xF6CD, 525}, {0xF6CE, 526},
        {0xF6CF, 527}, {0xF6D0, 528}, {0xF6D1, 529}, {0xF6D2, 530}, {0xF6D3, 531}
    };
    
    auto it = unicodeToNameIndex.find(unicodeValue);
    if (it != unicodeToNameIndex.end()) {
        return it->second;
    }
    
    // Для остальных Unicode символов генерируем имя по шаблону uniXXXX
    // Начинаем с 532 чтобы избежать конфликтов со стандартными именами
    static uint16_t nextUnicodeNameIndex = 532;
    
    // Проверяем не превысили ли максимальный индекс
    if (nextUnicodeNameIndex > MAX_STANDARD_NAME_INDEX) {
        std::cerr << "TTFRebuilder: Warning - exceeded maximum standard name index for Unicode glyph" << std::endl;
        return 0; // Возвращаем .notdef
    }
    
    return nextUnicodeNameIndex++;
}

uint16_t TTFRebuilder::generateCompositeGlyphName(uint16_t /*glyphIndex*/) {
    // Для составных глифов используем имена по шаблону compXXXX
    static uint16_t nextCompositeNameIndex = 1000;
    
    // Проверяем не превысили ли максимальный индекс
    if (nextCompositeNameIndex > MAX_STANDARD_NAME_INDEX) {
        std::cerr << "TTFRebuilder: Warning - exceeded maximum standard name index for composite glyph" << std::endl;
        return 0; // Возвращаем .notdef
    }
    
    return nextCompositeNameIndex++;
}

uint16_t TTFRebuilder::generateDefaultGlyphName(uint16_t /*glyphIndex*/) {
    // Для остальных глифов используем имена по шаблону gXXXX
    static uint16_t nextDefaultNameIndex = 2000;
    
    // Проверяем не превысили ли максимальный индекс
    if (nextDefaultNameIndex > MAX_STANDARD_NAME_INDEX) {
        std::cerr << "TTFRebuilder: Warning - exceeded maximum standard name index for default glyph" << std::endl;
        return 0; // Возвращаем .notdef
    }
    
    return nextDefaultNameIndex++;
}

void TTFRebuilder::validateTableData(const std::string& tag, size_t minSize) const {
    auto it = tables.find(tag);
    if (it == tables.end()) {
        throw std::runtime_error("Table '" + tag + "' not found");
    }
    if (it->second.data.size() < minSize) {
        throw std::runtime_error("Table '" + tag + "' too small, expected at least " + 
                               std::to_string(minSize) + " bytes, got " + 
                               std::to_string(it->second.data.size()));
    }
}

void TTFRebuilder::validateGlyphData() const {
    auto glyfIt = tables.find("glyf");
    if (glyfIt == tables.end()) return;
    
    const auto& glyfData = glyfIt->second.data;
    
    for (const auto& glyph : glyphOffsets) {
        if (glyph.isEmpty) continue;
        
        if (glyph.offset >= glyfData.size()) {
            throw std::runtime_error("Glyph offset beyond glyf table bounds");
        }
        
        if (glyph.offset + glyph.length > glyfData.size()) {
            throw std::runtime_error("Glyph extends beyond glyf table bounds");
        }
    }
}

uint32_t TTFRebuilder::calculateChecksum(const std::vector<uint8_t>& data) const {
    return calculateTableChecksum(data);
}

void TTFRebuilder::updateTableOffsets() {
    uint32_t currentOffset = sizeof(utils::TTFHeader) + 
                           tableOrder.size() * sizeof(utils::TableRecord);
    
    currentOffset = (currentOffset + 3) & ~3;
    
    for (auto& tableName : tableOrder) {
        auto& table = tables[tableName];
        table.newOffset = currentOffset;
        currentOffset += table.newLength;
        
        currentOffset = (currentOffset + 3) & ~3;
    }
}

void TTFRebuilder::rebuildTableDirectory() {
    utils::TTFHeader header;
    header.sfntVersion = TTF_MAGIC;
    header.numTables = static_cast<uint16_t>(tableOrder.size());
    
    uint16_t maxPower2 = 1;
    uint16_t entrySelector = 0;
    while (maxPower2 * 2 <= header.numTables) {
        maxPower2 *= 2;
        entrySelector++;
    }
    header.searchRange = maxPower2 * 16;
    header.entrySelector = entrySelector;
    header.rangeShift = (header.numTables - maxPower2) * 16;
    
    newData.resize(sizeof(utils::TTFHeader));
    std::memcpy(newData.data(), &header, sizeof(header));
    
    size_t tableRecordsOffset = newData.size();
    newData.resize(tableRecordsOffset + header.numTables * sizeof(utils::TableRecord));
    
    for (size_t i = 0; i < tableOrder.size(); ++i) {
        const auto& table = tables[tableOrder[i]];
        utils::TableRecord record;
        std::memcpy(record.tag, table.tag.c_str(), 4);
        record.checksum = calculateTableChecksum(table.data);
        record.offset = table.newOffset;
        record.length = table.newLength;
        
        std::memcpy(newData.data() + tableRecordsOffset + i * sizeof(record), 
                   &record, sizeof(record));
    }
}

void TTFRebuilder::updateHeadTableChecksumAdjustment() {
    auto headTable = tables.find("head");
    if (headTable == tables.end()) return;
    
    uint32_t fontChecksum = 0;
    
    uint32_t headerChecksum = calculateTableChecksum(
        std::vector<uint8_t>(newData.begin(), newData.begin() + sizeof(utils::TTFHeader) + 
                            tableOrder.size() * sizeof(utils::TableRecord))
    );
    fontChecksum += headerChecksum;
    
    for (const auto& table : tableOrder) {
        fontChecksum += calculateTableChecksum(tables[table].data);
    }
    
    uint32_t checksumAdjustment = 0xB1B0AFBA - fontChecksum;
    
    if (headTable->second.data.size() >= 12) {
        setUInt32(headTable->second.data, 8, checksumAdjustment);
    }
}

uint32_t TTFRebuilder::calculateTableChecksum(const std::vector<uint8_t>& data) const {
    uint32_t sum = 0;
    size_t nLongs = (data.size() + 3) / 4;
    
    for (size_t i = 0; i < nLongs; ++i) {
        uint32_t value = 0;
        size_t bytesToCopy = std::min(size_t(4), data.size() - i * 4);
        std::memcpy(&value, data.data() + i * 4, bytesToCopy);
        sum += value;
    }
    
    return sum;
}

} // namespace fontmaster

--------------------------------

./src/qt/MainWindow.h
#pragma once

#include <QMainWindow>
#include <QTreeWidget>
#include <QListWidget>
#include <QPushButton>
#include <QLabel>
#include <QMenuBar>
#include <QStatusBar>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QFileDialog>
#include <QMessageBox>
#include <QHeaderView>
#include "fontmaster/FontMaster.h"

class MainWindow : public QMainWindow {
    Q_OBJECT

public:
    MainWindow(QWidget *parent = nullptr);

private slots:
    void openFont();
    void saveFont();
    void removeSelectedGlyph();
    void replaceGlyphImage();
    void glyphSelectionChanged();
    void updateGlyphPreview();

private:
    void setupUI();
    void loadFont(const QString& filepath);
    void refreshGlyphList();
    void clearFont();
    
    QTreeWidget *glyphTree;
    QListWidget *glyphPreview;
    QPushButton *btnOpen;
    QPushButton *btnSave;
    QPushButton *btnRemove;
    QPushButton *btnReplace;
    QLabel *statusLabel;
    QLabel *fontInfoLabel;
    
    std::unique_ptr<fontmaster::Font> currentFont;
    QString currentFontPath;
};

--------------------------------

./src/qt/main.cpp
#include "MainWindow.h"
#include <QApplication>

int main(int argc, char *argv[]) {
    QApplication app(argc, argv);
    
    // Настройка приложения
    app.setApplicationName("FontMaster");
    app.setApplicationVersion("1.0.0");
    app.setOrganizationName("FontMaster");
    
    MainWindow window;
    window.show();
    
    return app.exec();
}

--------------------------------

./src/qt/MainWindow.cpp
#include "MainWindow.h"
#include <QScrollArea>
#include <QGroupBox>

MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) {
    setupUI();
    setWindowTitle("FontMaster - Emoji Font Editor");
    setMinimumSize(1000, 700);
    
    statusLabel->setText("Ready - No font loaded");
}

void MainWindow::setupUI() {
    QWidget *centralWidget = new QWidget(this);
    setCentralWidget(centralWidget);
    
    QHBoxLayout *mainLayout = new QHBoxLayout(centralWidget);
    
    // Левая панель - список глифов и управление
    QWidget *leftPanel = new QWidget(this);
    QVBoxLayout *leftLayout = new QVBoxLayout(leftPanel);
    
    // Информация о шрифте
    fontInfoLabel = new QLabel("No font loaded", this);
    fontInfoLabel->setWordWrap(true);
    fontInfoLabel->setStyleSheet("QLabel { background-color: #f0f0f0; padding: 5px; border: 1px solid #ccc; }");
    leftLayout->addWidget(fontInfoLabel);
    
    // Панель управления
    QHBoxLayout *controlLayout = new QHBoxLayout();
    btnOpen = new QPushButton("Open Font", this);
    btnSave = new QPushButton("Save Font", this);
    btnRemove = new QPushButton("Remove Glyph", this);
    btnReplace = new QPushButton("Replace Image", this);
    
    btnSave->setEnabled(false);
    btnRemove->setEnabled(false);
    btnReplace->setEnabled(false);
    
    controlLayout->addWidget(btnOpen);
    controlLayout->addWidget(btnSave);
    controlLayout->addWidget(btnRemove);
    controlLayout->addWidget(btnReplace);
    leftLayout->addLayout(controlLayout);
    
    // Список глифов
    glyphTree = new QTreeWidget(this);
    glyphTree->setHeaderLabels({"Glyph Name", "Unicode", "Format", "Size"});
    glyphTree->setSortingEnabled(true);
    glyphTree->setSelectionMode(QTreeWidget::SingleSelection);
    leftLayout->addWidget(glyphTree, 1);
    
    // Правая панель - превью
    QWidget *rightPanel = new QWidget(this);
    QVBoxLayout *rightLayout = new QVBoxLayout(rightPanel);
    
    QLabel *previewLabel = new QLabel("Glyph Preview", this);
    previewLabel->setAlignment(Qt::AlignCenter);
    rightLayout->addWidget(previewLabel);
    
    glyphPreview = new QListWidget(this);
    rightLayout->addWidget(glyphPreview, 1);
    
    statusLabel = new QLabel(this);
    statusLabel->setAlignment(Qt::AlignCenter);
    statusLabel->setStyleSheet("QLabel { background-color: #e0e0e0; padding: 3px; }");
    rightLayout->addWidget(statusLabel);
    
    mainLayout->addWidget(leftPanel, 2);
    mainLayout->addWidget(rightPanel, 1);
    
    // Меню
    QMenu *fileMenu = menuBar()->addMenu("File");
    fileMenu->addAction("Open Font", this, &MainWindow::openFont);
    fileMenu->addAction("Save Font", this, &MainWindow::saveFont);
    fileMenu->addSeparator();
    fileMenu->addAction("Exit", this, &QWidget::close);
    
    // Соединения
    connect(btnOpen, &QPushButton::clicked, this, &MainWindow::openFont);
    connect(btnSave, &QPushButton::clicked, this, &MainWindow::saveFont);
    connect(btnRemove, &QPushButton::clicked, this, &MainWindow::removeSelectedGlyph);
    connect(btnReplace, &QPushButton::clicked, this, &MainWindow::replaceGlyphImage);
    connect(glyphTree, &QTreeWidget::itemSelectionChanged, 
            this, &MainWindow::glyphSelectionChanged);
}

void MainWindow::openFont() {
    QString filepath = QFileDialog::getOpenFileName(this, "Open Font File", 
                                                   "", "Font Files (*.ttf *.otf)");
    if (!filepath.isEmpty()) {
        loadFont(filepath);
    }
}

void MainWindow::saveFont() {
    if (!currentFont) return;
    
    QString filepath = QFileDialog::getSaveFileName(this, "Save Font File", 
                                                   currentFontPath + ".modified.ttf",
                                                   "Font Files (*.ttf)");
    if (!filepath.isEmpty()) {
        try {
            if (currentFont->save(filepath.toStdString())) {
                QMessageBox::information(this, "Success", 
                    "Font saved successfully to:\n" + filepath);
            } else {
                QMessageBox::warning(this, "Error", "Failed to save font");
            }
        } catch (const std::exception& e) {
            QMessageBox::warning(this, "Error", 
                QString("Failed to save font:\n") + e.what());
        }
    }
}

void MainWindow::loadFont(const QString& filepath) {
    try {
        clearFont();
        
        currentFont = fontmaster::Font::load(filepath.toStdString());
        if (currentFont) {
            currentFontPath = filepath;
            refreshGlyphList();
            
            // Обновляем информацию о шрифте
            QString formatStr;
            switch (currentFont->getFormat()) {
                case fontmaster::FontFormat::CBDT_CBLC: formatStr = "Google CBDT/CBLC"; break;
                case fontmaster::FontFormat::SBIX: formatStr = "Apple SBIX"; break;
                case fontmaster::FontFormat::COLR_CPAL: formatStr = "Microsoft COLR/CPAL"; break;
                case fontmaster::FontFormat::SVG: formatStr = "Adobe SVG"; break;
                default: formatStr = "Unknown"; break;
            }
            
            auto glyphs = currentFont->listGlyphs();
            fontInfoLabel->setText(
                QString("File: %1\nFormat: %2\nGlyphs: %3")
                    .arg(QFileInfo(filepath).fileName())
                    .arg(formatStr)
                    .arg(glyphs.size())
            );
            
            statusLabel->setText("Font loaded successfully");
            btnSave->setEnabled(true);
            
        } else {
            QMessageBox::warning(this, "Error", "Cannot load font: " + filepath);
        }
    } catch (const std::exception& e) {
        QMessageBox::warning(this, "Error", 
            QString("Error loading font:\n") + e.what());
    }
}

void MainWindow::refreshGlyphList() {
    glyphTree->clear();
    
    if (!currentFont) return;
    
    try {
        auto glyphs = currentFont->listGlyphs();
        for (const auto& glyph : glyphs) {
            QTreeWidgetItem *item = new QTreeWidgetItem(glyphTree);
            item->setText(0, QString::fromStdString(glyph.name));
            
            if (glyph.unicode != 0) {
                item->setText(1, QString("U+%1").arg(glyph.unicode, 4, 16, QChar('0')).toUpper());
            }
            
            item->setText(2, QString::fromStdString(glyph.format));
            item->setText(3, QString("%1 bytes").arg(glyph.data_size));
        }
        
        glyphTree->header()->resizeSections(QHeaderView::ResizeToContents);
        statusLabel->setText(QString("Loaded %1 glyphs").arg(glyphs.size()));
        
    } catch (const std::exception& e) {
        statusLabel->setText("Error loading glyph list: " + QString(e.what()));
    }
}

void MainWindow::removeSelectedGlyph() {
    auto selectedItems = glyphTree->selectedItems();
    if (selectedItems.isEmpty() || !currentFont) return;
    
    QTreeWidgetItem *item = selectedItems.first();
    QString glyphName = item->text(0);
    
    int result = QMessageBox::question(this, "Remove Glyph", 
        "Are you sure you want to remove glyph:\n" + glyphName + "?");
    
    if (result == QMessageBox::Yes) {
        try {
            if (currentFont->removeGlyph(glyphName.toStdString())) {
                delete item;
                statusLabel->setText("Glyph removed: " + glyphName);
                btnSave->setEnabled(true);
            } else {
                QMessageBox::warning(this, "Error", "Failed to remove glyph");
            }
        } catch (const std::exception& e) {
            QMessageBox::warning(this, "Error", 
                QString("Failed to remove glyph:\n") + e.what());
        }
    }
}

void MainWindow::replaceGlyphImage() {
    auto selectedItems = glyphTree->selectedItems();
    if (selectedItems.isEmpty() || !currentFont) return;
    
    QTreeWidgetItem *item = selectedItems.first();
    QString glyphName = item->text(0);
    
    QString imagePath = QFileDialog::getOpenFileName(this, 
        "Select Replacement Image", "", "Image Files (*.png *.jpg *.bmp)");
    
    if (!imagePath.isEmpty()) {
        try {
            QFile file(imagePath);
            if (!file.open(QIODevice::ReadOnly)) {
                QMessageBox::warning(this, "Error", "Cannot open image file");
                return;
            }
            
            QByteArray imageData = file.readAll();
            std::vector<uint8_t> imageVec(imageData.begin(), imageData.end());
            
            if (currentFont->replaceGlyphImage(glyphName.toStdString(), imageVec)) {
                statusLabel->setText("Image replaced for: " + glyphName);
                btnSave->setEnabled(true);
            } else {
                QMessageBox::warning(this, "Error", "Failed to replace glyph image");
            }
        } catch (const std::exception& e) {
            QMessageBox::warning(this, "Error", 
                QString("Failed to replace image:\n") + e.what());
        }
    }
}

void MainWindow::glyphSelectionChanged() {
    auto selectedItems = glyphTree->selectedItems();
    bool hasSelection = !selectedItems.isEmpty();
    
    btnRemove->setEnabled(hasSelection);
    btnReplace->setEnabled(hasSelection);
    
    updateGlyphPreview();
}

void MainWindow::updateGlyphPreview() {
    glyphPreview->clear();
    
    auto selectedItems = glyphTree->selectedItems();
    if (selectedItems.isEmpty() || !currentFont) return;
    
    QTreeWidgetItem *item = selectedItems.first();
    QString glyphName = item->text(0);
    
    try {
        auto glyphInfo = currentFont->getGlyphInfo(glyphName.toStdString());
        
        QString previewText = QString("Glyph: %1\nUnicode: U+%2\nFormat: %3\nSize: %4 bytes")
            .arg(glyphName)
            .arg(glyphInfo.unicode, 4, 16, QChar('0')).toUpper()
            .arg(QString::fromStdString(glyphInfo.format))
            .arg(glyphInfo.data_size);
        
        glyphPreview->addItem(previewText);
        
        // Здесь можно добавить отображение самого изображения глифа
        // Для этого нужно конвертировать image_data в QPixmap
        
    } catch (const std::exception& e) {
        glyphPreview->addItem("Error loading glyph details: " + QString(e.what()));
    }
}

void MainWindow::clearFont() {
    currentFont.reset();
    glyphTree->clear();
    glyphPreview->clear();
    fontInfoLabel->setText("No font loaded");
    statusLabel->setText("Ready - No font loaded");
    btnSave->setEnabled(false);
    btnRemove->setEnabled(false);
    btnReplace->setEnabled(false);
}

--------------------------------

./src/cli/main.cpp
#include "fontmaster/FontMaster.h"
#include <iostream>
#include <iomanip>
#include <cstring>
#include <fstream>

class CommandProcessor {
public:
    static int processList(int argc, char* argv[]) {
        if (argc != 3) {
            std::cerr << "Usage: fontmaster-cli list <fontfile>" << std::endl;
            return 1;
        }
        
        try {
            auto font = fontmaster::Font::load(argv[2]);
            if (!font) {
                std::cerr << "Error: Cannot load font " << argv[2] << std::endl;
                return 1;
            }
            
            std::cout << "Font format: ";
            switch (font->getFormat()) {
                case fontmaster::FontFormat::CBDT_CBLC: std::cout << "Google CBDT/CBLC"; break;
                case fontmaster::FontFormat::SBIX: std::cout << "Apple SBIX"; break;
                case fontmaster::FontFormat::COLR_CPAL: std::cout << "Microsoft COLR/CPAL"; break;
                case fontmaster::FontFormat::SVG: std::cout << "Adobe SVG"; break;
                default: std::cout << "Unknown"; break;
            }
            std::cout << std::endl;
            
            auto glyphs = font->listGlyphs();
            std::cout << "Glyphs count: " << glyphs.size() << std::endl;
            
            for (const auto& glyph : glyphs) {
                std::cout << "  " << glyph.name;
                if (glyph.unicode != 0) {
                    std::cout << " (U+" << std::hex << std::uppercase << std::setw(4) 
                              << std::setfill('0') << glyph.unicode << std::dec << ")";
                }
                std::cout << " - " << glyph.format;
                std::cout << " - " << glyph.data_size << " bytes";
                std::cout << std::endl;
            }
            
            return 0;
        } catch (const fontmaster::FontException& e) {
            std::cerr << "Error: " << e.what() << std::endl;
            return 1;
        }
    }
    
    static int processRemove(int argc, char* argv[]) {
        std::string fontFile;
        std::string glyphName;
        std::string unicodeStr;
        std::string outputFile;
        
        for (int i = 2; i < argc; i++) {
            std::string arg = argv[i];
            if (arg == "--font" && i + 1 < argc) {
                fontFile = argv[++i];
            } else if (arg == "--name" && i + 1 < argc) {
                glyphName = argv[++i];
            } else if (arg == "--unicode" && i + 1 < argc) {
                unicodeStr = argv[++i];
            } else if (arg == "--output" && i + 1 < argc) {
                outputFile = argv[++i];
            }
        }
        
        if (fontFile.empty() || (glyphName.empty() && unicodeStr.empty())) {
            std::cerr << "Usage: fontmaster-cli remove --font <file> (--name <name> | --unicode <hex>) [--output <file>]" << std::endl;
            return 1;
        }
        
        if (outputFile.empty()) {
            outputFile = fontFile + ".modified.ttf";
        }
        
        try {
            auto font = fontmaster::Font::load(fontFile);
            if (!font) {
                std::cerr << "Error: Cannot load font " << fontFile << std::endl;
                return 1;
            }
            
            bool success = false;
            if (!glyphName.empty()) {
                std::cout << "Removing glyph by name: " << glyphName << std::endl;
                success = font->removeGlyph(glyphName);
            } else {
                uint32_t unicode = std::stoul(unicodeStr, nullptr, 16);
                std::cout << "Removing glyph by Unicode: U+" << unicodeStr << std::endl;
                success = font->removeGlyph(unicode);
            }
            
            if (success) {
                if (font->save(outputFile)) {
                    std::cout << "Success! Modified font saved as: " << outputFile << std::endl;
                } else {
                    std::cerr << "Error: Failed to save modified font" << std::endl;
                    return 1;
                }
            } else {
                std::cerr << "Error: Failed to remove glyph" << std::endl;
                return 1;
            }
            
            return 0;
        } catch (const fontmaster::FontException& e) {
            std::cerr << "Error: " << e.what() << std::endl;
            return 1;
        } catch (const std::exception& e) {
            std::cerr << "Unexpected error: " << e.what() << std::endl;
            return 1;
        }
    }
    
    static int processReplace(int argc, char* argv[]) {
        std::string fontFile;
        std::string glyphName;
        std::string imageFile;
        std::string outputFile;
        
        for (int i = 2; i < argc; i++) {
            std::string arg = argv[i];
            if (arg == "--font" && i + 1 < argc) {
                fontFile = argv[++i];
            } else if (arg == "--name" && i + 1 < argc) {
                glyphName = argv[++i];
            } else if (arg == "--image" && i + 1 < argc) {
                imageFile = argv[++i];
            } else if (arg == "--output" && i + 1 < argc) {
                outputFile = argv[++i];
            }
        }
        
        if (fontFile.empty() || glyphName.empty() || imageFile.empty()) {
            std::cerr << "Usage: fontmaster-cli replace --font <file> --name <name> --image <file> [--output <file>]" << std::endl;
            return 1;
        }
        
        if (outputFile.empty()) {
            outputFile = fontFile + ".modified.ttf";
        }
        
        try {
            // Читаем файл изображения
            std::ifstream image(imageFile, std::ios::binary);
            if (!image) {
                std::cerr << "Error: Cannot open image file " << imageFile << std::endl;
                return 1;
            }
            
            image.seekg(0, std::ios::end);
            size_t size = image.tellg();
            image.seekg(0, std::ios::beg);
            
            std::vector<uint8_t> imageData(size);
            image.read(reinterpret_cast<char*>(imageData.data()), size);
            
            auto font = fontmaster::Font::load(fontFile);
            if (!font) {
                std::cerr << "Error: Cannot load font " << fontFile << std::endl;
                return 1;
            }
            
            std::cout << "Replacing image for glyph: " << glyphName << std::endl;
            if (font->replaceGlyphImage(glyphName, imageData)) {
                if (font->save(outputFile)) {
                    std::cout << "Success! Modified font saved as: " << outputFile << std::endl;
                } else {
                    std::cerr << "Error: Failed to save modified font" << std::endl;
                    return 1;
                }
            } else {
                std::cerr << "Error: Failed to replace glyph image" << std::endl;
                return 1;
            }
            
            return 0;
        } catch (const fontmaster::FontException& e) {
            std::cerr << "Error: " << e.what() << std::endl;
            return 1;
        } catch (const std::exception& e) {
            std::cerr << "Unexpected error: " << e.what() << std::endl;
            return 1;
        }
    }
    
    static int processInfo(int argc, char* argv[]) {
        if (argc != 3) {
            std::cerr << "Usage: fontmaster-cli info <fontfile>" << std::endl;
            return 1;
        }
        
        try {
            auto font = fontmaster::Font::load(argv[2]);
            if (!font) {
                std::cerr << "Error: Cannot load font " << argv[2] << std::endl;
                return 1;
            }
            
            std::cout << "Font Information:" << std::endl;
            std::cout << "  Format: ";
            switch (font->getFormat()) {
                case fontmaster::FontFormat::CBDT_CBLC: std::cout << "Google CBDT/CBLC"; break;
                case fontmaster::FontFormat::SBIX: std::cout << "Apple SBIX"; break;
                case fontmaster::FontFormat::COLR_CPAL: std::cout << "Microsoft COLR/CPAL"; break;
                case fontmaster::FontFormat::SVG: std::cout << "Adobe SVG"; break;
                default: std::cout << "Unknown"; break;
            }
            std::cout << std::endl;
            
            auto glyphs = font->listGlyphs();
            std::cout << "  Glyph count: " << glyphs.size() << std::endl;
            
            size_t totalSize = 0;
            for (const auto& glyph : glyphs) {
                totalSize += glyph.data_size;
            }
            std::cout << "  Total image data: " << totalSize << " bytes" << std::endl;
            
            return 0;
        } catch (const fontmaster::FontException& e) {
            std::cerr << "Error: " << e.what() << std::endl;
            return 1;
        }
    }
};

void printUsage() {
    std::cout << "FontMaster - Universal Emoji Font Tool" << std::endl;
    std::cout << "Usage: fontmaster-cli <command> [options]" << std::endl;
    std::cout << "Commands:" << std::endl;
    std::cout << "  list <fontfile>                                 List all glyphs" << std::endl;
    std::cout << "  remove --font <font> --name <name>              Remove glyph by name" << std::endl;
    std::cout << "  remove --font <font> --unicode <hex>            Remove glyph by unicode" << std::endl;
    std::cout << "  replace --font <font> --name <name> --image <file>  Replace glyph image" << std::endl;
    std::cout << "  info <fontfile>                                 Show font information" << std::endl;
    std::cout << std::endl;
    std::cout << "Supported formats: CBDT/CBLC (Google), SBIX (Apple), COLR/CPAL (Microsoft), SVG (Adobe)" << std::endl;
}

int main(int argc, char* argv[]) {
    if (argc < 2) {
        printUsage();
        return 1;
    }
    
    std::string command = argv[1];
    
    try {
        if (command == "list") {
            return CommandProcessor::processList(argc, argv);
        } else if (command == "remove") {
            return CommandProcessor::processRemove(argc, argv);
        } else if (command == "replace") {
            return CommandProcessor::processReplace(argc, argv);
        } else if (command == "info") {
            return CommandProcessor::processInfo(argc, argv);
        } else if (command == "help" || command == "--help" || command == "-h") {
            printUsage();
            return 0;
        } else {
            std::cerr << "Unknown command: " << command << std::endl;
            printUsage();
            return 1;
        }
    } catch (const std::exception& e) {
        std::cerr << "Unexpected error: " << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}

--------------------------------

./src/cli/CommandProcessor.cpp
#include "fontmaster/FontMaster.h"
#include <iostream>
#include <iomanip>

class CommandProcessor {
public:
    static int processList(int argc, char* argv[]) {
        if (argc != 3) {
            std::cerr << "Usage: fontmaster-cli list <fontfile>" << std::endl;
            return 1;
        }
        
        auto font = fontmaster::Font::load(argv[2]);
        if (!font) {
            std::cerr << "Error: Cannot load font " << argv[2] << std::endl;
            return 1;
        }
        
        std::cout << "Font format: ";
        switch (font->getFormat()) {
            case fontmaster::FontFormat::CBDT_CBLC: std::cout << "Google CBDT/CBLC"; break;
            case fontmaster::FontFormat::SBIX: std::cout << "Apple SBIX"; break;
            case fontmaster::FontFormat::COLR_CPAL: std::cout << "Microsoft COLR/CPAL"; break;
            case fontmaster::FontFormat::SVG: std::cout << "Adobe SVG"; break;
            default: std::cout << "Unknown"; break;
        }
        std::cout << std::endl;
        
        auto glyphs = font->listGlyphs();
        std::cout << "Glyphs count: " << glyphs.size() << std::endl;
        
        for (const auto& glyph : glyphs) {
            std::cout << "  " << glyph.name 
                      << " (U+" << std::hex << std::uppercase << std::setw(4) 
                      << std::setfill('0') << glyph.unicode << std::dec << ")"
                      << " - " << glyph.format
                      << " - " << glyph.image_data.size() << " bytes"
                      << std::endl;
        }
        
        return 0;
    }
    
    static int processRemove(int argc, char* argv[]) {
        std::string fontFile;
        std::string glyphName;
        std::string unicodeStr;
        
        for (int i = 2; i < argc; i++) {
            std::string arg = argv[i];
            if (arg == "--font" && i + 1 < argc) {
                fontFile = argv[++i];
            } else if (arg == "--name" && i + 1 < argc) {
                glyphName = argv[++i];
            } else if (arg == "--unicode" && i + 1 < argc) {
                unicodeStr = argv[++i];
            }
        }
        
        if (fontFile.empty() || (glyphName.empty() && unicodeStr.empty())) {
            std::cerr << "Usage: fontmaster-cli remove --font <file> (--name <name> | --unicode <hex>)" << std::endl;
            return 1;
        }
        
        auto font = fontmaster::Font::load(fontFile);
        if (!font) {
            std::cerr << "Error: Cannot load font " << fontFile << std::endl;
            return 1;
        }
        
        bool success = false;
        if (!glyphName.empty()) {
            success = font->removeGlyph(glyphName);
            std::cout << "Removing glyph by name: " << glyphName << std::endl;
        } else {
            uint32_t unicode = std::stoul(unicodeStr, nullptr, 16);
            success = font->removeGlyph(unicode);
            std::cout << "Removing glyph by Unicode: U+" << unicodeStr << std::endl;
        }
        
        if (success) {
            std::string outputFile = fontFile + ".modified.ttf";
            if (font->save(outputFile)) {
                std::cout << "Success! Modified font saved as: " << outputFile << std::endl;
            } else {
                std::cerr << "Error: Failed to save modified font" << std::endl;
                return 1;
            }
        } else {
            std::cerr << "Error: Failed to remove glyph" << std::endl;
            return 1;
        }
        
        return 0;
    }
};

--------------------------------

./src/formats/COLR_CPAL_Handler.cpp
#include "fontmaster/FontMaster.h"
#include "fontmaster/TTFUtils.h"

namespace fontmaster {

class COLR_CPAL_Handler : public FontFormatHandler {
public:
    bool canHandle(const std::string& filepath) override {
        try {
            std::ifstream file(filepath, std::ios::binary);
            if (!file) return false;
            
            file.seekg(0, std::ios::end);
            size_t size = file.tellg();
            file.seekg(0, std::ios::beg);
            
            if (size < 1024) return false;
            
            std::vector<uint8_t> header(1024);
            file.read(reinterpret_cast<char*>(header.data()), header.size());
            
            auto tables = utils::parseTTFTables(header);
            return utils::hasTable(tables, "COLR") && utils::hasTable(tables, "CPAL");
        } catch (...) {
            return false;
        }
    }
    
    std::unique_ptr<Font> loadFont(const std::string& filepath) override {
        return std::make_unique<COLR_CPAL_Font>(filepath);
    }
    
    FontFormat getFormat() const override { return FontFormat::COLR_CPAL; }
};

class COLR_CPAL_Font : public Font {
private:
    std::string filepath;
    std::vector<uint8_t> fontData;
    std::map<std::string, GlyphInfo> colorGlyphs;
    std::vector<std::string> removedGlyphs;
    
public:
    COLR_CPAL_Font(const std::string& path) : filepath(path) {
        loadFontData();
        parseFont();
    }
    
private:
    void loadFontData() {
        std::ifstream file(filepath, std::ios::binary);
        if (!file) {
            throw FontLoadException(filepath, "Cannot open file");
        }
        
        file.seekg(0, std::ios::end);
        size_t size = file.tellg();
        file.seekg(0, std::ios::beg);
        
        fontData.resize(size);
        if (!file.read(reinterpret_cast<char*>(fontData.data()), size)) {
            throw FontLoadException(filepath, "Cannot read file data");
        }
    }
    
    void parseFont() {
        auto tables = utils::parseTTFTables(fontData);
        if (!utils::hasTable(tables, "COLR") || !utils::hasTable(tables, "CPAL")) {
            throw FontFormatException("COLR/CPAL", "Required tables not found");
        }
        
        std::cout << "COLR/CPAL tables found" << std::endl;
        
        // Заглушка для демонстрации
        for (int i = 0; i < 10; ++i) {
            std::string glyphName = "colr_glyph_" + std::to_string(i);
            GlyphInfo info;
            info.name = glyphName;
            info.unicode = 0x1F600 + i;
            info.format = "colr";
            info.data_size = 0;
            colorGlyphs[glyphName] = info;
        }
    }
    
public:
    FontFormat getFormat() const override { return FontFormat::COLR_CPAL; }
    
    bool removeGlyph(const std::string& glyphName) override {
        auto it = colorGlyphs.find(glyphName);
        if (it == colorGlyphs.end()) {
            return false;
        }
        
        colorGlyphs.erase(it);
        removedGlyphs.push_back(glyphName);
        return true;
    }
    
    bool removeGlyph(uint32_t unicode) override {
        for (const auto& pair : colorGlyphs) {
            if (pair.second.unicode == unicode) {
                return removeGlyph(pair.first);
            }
        }
        return false;
    }
    
    bool replaceGlyphImage(const std::string& glyphName,
                          const std::vector<uint8_t>& newImage) override {
        // COLR/CPAL использует векторные слои, а не растровые изображения
        // Замена сложнее и требует модификации векторных данных
        std::cerr << "Warning: Image replacement for COLR/CPAL fonts is not fully supported" << std::endl;
        return false;
    }
    
    std::vector<GlyphInfo> listGlyphs() const override {
        std::vector<GlyphInfo> result;
        for (const auto& pair : colorGlyphs) {
            if (std::find(removedGlyphs.begin(), removedGlyphs.end(), pair.first) != removedGlyphs.end()) {
                continue;
            }
            result.push_back(pair.second);
        }
        return result;
    }
    
    GlyphInfo getGlyphInfo(const std::string& glyphName) const override {
        auto it = colorGlyphs.find(glyphName);
        if (it != colorGlyphs.end()) {
            return it->second;
        }
        throw GlyphNotFoundException(glyphName);
    }
    
    std::string findGlyphName(uint32_t unicode) const override {
        for (const auto& pair : colorGlyphs) {
            if (pair.second.unicode == unicode) {
                return pair.first;
            }
        }
        return "";
    }
    
    bool save(const std::string& outputPath) override {
        try {
            std::ofstream file(outputPath, std::ios::binary);
            if (!file) {
                throw FontSaveException(outputPath, "Cannot create output file");
            }
            
            file.write(reinterpret_cast<const char*>(fontData.data()), fontData.size());
            return file.good();
        } catch (const std::exception& e) {
            throw FontSaveException(outputPath, std::string("Save failed: ") + e.what());
        }
    }
};

static bool registerCOLRHandler() {
    FontMasterImpl::instance().registerHandler(
        std::make_unique<COLR_CPAL_Handler>()
    );
    return true;
}

static bool colrHandlerRegistered = registerCOLRHandler();

} // namespace fontmaster

--------------------------------

./src/formats/SBIX_Handler.cpp
#include "fontmaster/FontMaster.h"
#include "fontmaster/TTFUtils.h"
#include <fstream>

namespace fontmaster {

class SBIX_Handler : public FontFormatHandler {
public:
    bool canHandle(const std::string& filepath) override {
        try {
            std::ifstream file(filepath, std::ios::binary);
            if (!file) return false;
            
            file.seekg(0, std::ios::end);
            size_t size = file.tellg();
            file.seekg(0, std::ios::beg);
            
            if (size < 1024) return false;
            
            std::vector<uint8_t> header(1024);
            file.read(reinterpret_cast<char*>(header.data()), header.size());
            
            auto tables = utils::parseTTFTables(header);
            return utils::hasTable(tables, "sbix");
        } catch (...) {
            return false;
        }
    }
    
    std::unique_ptr<Font> loadFont(const std::string& filepath) override {
        return std::make_unique<SBIX_Font>(filepath);
    }
    
    FontFormat getFormat() const override { return FontFormat::SBIX; }
};

class SBIX_Font : public Font {
private:
    std::string filepath;
    std::vector<uint8_t> fontData;
    std::map<std::string, std::vector<uint8_t>> glyphImages;
    std::vector<std::string> removedGlyphs;
    
public:
    SBIX_Font(const std::string& path) : filepath(path) {
        loadFontData();
        parseFont();
    }
    
private:
    void loadFontData() {
        std::ifstream file(filepath, std::ios::binary);
        if (!file) {
            throw FontLoadException(filepath, "Cannot open file");
        }
        
        file.seekg(0, std::ios::end);
        size_t size = file.tellg();
        file.seekg(0, std::ios::beg);
        
        fontData.resize(size);
        if (!file.read(reinterpret_cast<char*>(fontData.data()), size)) {
            throw FontLoadException(filepath, "Cannot read file data");
        }
    }
    
    void parseFont() {
        auto tables = utils::parseTTFTables(fontData);
        if (!utils::hasTable(tables, "sbix")) {
            throw FontFormatException("SBIX", "sbix table not found");
        }
        
        // Упрощенный парсинг для демонстрации
        std::cout << "SBIX table found" << std::endl;
        
        // Заглушка для демонстрации
        for (int i = 0; i < 10; ++i) {
            std::string glyphName = "u1F6" + std::to_string(i) + "0";
            glyphImages[glyphName] = {0x89, 0x50, 0x4E, 0x47}; // PNG header
        }
    }
    
public:
    FontFormat getFormat() const override { return FontFormat::SBIX; }
    
    bool removeGlyph(const std::string& glyphName) override {
        auto it = glyphImages.find(glyphName);
        if (it == glyphImages.end()) {
            return false;
        }
        
        glyphImages.erase(it);
        removedGlyphs.push_back(glyphName);
        return true;
    }
    
    bool removeGlyph(uint32_t unicode) override {
        std::string name = findGlyphName(unicode);
        if (name.empty()) return false;
        return removeGlyph(name);
    }
    
    bool replaceGlyphImage(const std::string& glyphName,
                          const std::vector<uint8_t>& newImage) override {
        auto it = glyphImages.find(glyphName);
        if (it == glyphImages.end()) {
            return false;
        }
        
        it->second = newImage;
        return true;
    }
    
    std::vector<GlyphInfo> listGlyphs() const override {
        std::vector<GlyphInfo> result;
        for (const auto& pair : glyphImages) {
            if (std::find(removedGlyphs.begin(), removedGlyphs.end(), pair.first) != removedGlyphs.end()) {
                continue;
            }
            
            GlyphInfo info;
            info.name = pair.first;
            info.format = "png";
            info.image_data = pair.second;
            info.data_size = pair.second.size();
            result.push_back(info);
        }
        return result;
    }
    
    GlyphInfo getGlyphInfo(const std::string& glyphName) const override {
        auto it = glyphImages.find(glyphName);
        if (it != glyphImages.end()) {
            GlyphInfo info;
            info.name = glyphName;
            info.format = "png";
            info.image_data = it->second;
            info.data_size = it->second.size();
            return info;
        }
        throw GlyphNotFoundException(glyphName);
    }
    
    std::string findGlyphName(uint32_t unicode) const override {
        std::string expectedName = "u" + std::to_string(unicode);
        return glyphImages.count(expectedName) ? expectedName : "";
    }
    
    bool save(const std::string& outputPath) override {
        try {
            std::ofstream file(outputPath, std::ios::binary);
            if (!file) {
                throw FontSaveException(outputPath, "Cannot create output file");
            }
            
            file.write(reinterpret_cast<const char*>(fontData.data()), fontData.size());
            return file.good();
        } catch (const std::exception& e) {
            throw FontSaveException(outputPath, std::string("Save failed: ") + e.what());
        }
    }
};

static bool registerSBIXHandler() {
    FontMasterImpl::instance().registerHandler(
        std::make_unique<SBIX_Handler>()
    );
    return true;
}

static bool sbixHandlerRegistered = registerSBIXHandler();

} // namespace fontmaster

--------------------------------

./src/formats/CBDT_CBLC_Rebuilder.cpp
#include "fontmaster/CBDT_CBLC_Rebuilder.h"
#include "fontmaster/TTFUtils.h"
#include <iostream>
#include <algorithm>
#include <cstring>

namespace fontmaster {

using namespace fontmaster::utils;

static inline void appendUInt32(std::vector<uint8_t>& data, uint32_t value) {
    data.push_back((value >> 24) & 0xFF);
    data.push_back((value >> 16) & 0xFF);
    data.push_back((value >> 8) & 0xFF);
    data.push_back(value & 0xFF);
}

static inline void appendUInt16(std::vector<uint8_t>& data, uint16_t value) {
    data.push_back((value >> 8) & 0xFF);
    data.push_back(value & 0xFF);
}

static inline void setUInt32(std::vector<uint8_t>& data, size_t offset, uint32_t value) {
    if (offset + 4 <= data.size()) {
        data[offset] = (value >> 24) & 0xFF;
        data[offset + 1] = (value >> 16) & 0xFF;
        data[offset + 2] = (value >> 8) & 0xFF;
        data[offset + 3] = value & 0xFF;
    }
}

static inline uint32_t calcTableChecksum(const std::vector<uint8_t>& data) {
    uint32_t sum = 0;
    for (size_t i = 0; i < data.size(); i += 4) {
        uint32_t val = 0;
        for (int j = 0; j < 4 && i + j < data.size(); ++j)
            val = (val << 8) | data[i + j];
        sum += val;
    }
    return sum;
}

static inline void setTag(std::vector<uint8_t>& buf, size_t offset, const std::string& tag) {
    for (size_t i = 0; i < 4; ++i)
        buf[offset + i] = (i < tag.size()) ? tag[i] : ' ';
}

/* ────────────────────────────────  MAIN  ─────────────────────────────── */

std::vector<uint8_t> CBDT_CBLC_Rebuilder::rebuild() {
    std::vector<uint8_t> cblcData;
    std::vector<uint8_t> cbdtData;

    rebuildCBLCTable(cblcData);
    rebuildCBDTTable(cbdtData);

    return createUpdatedFont(cblcData, cbdtData);
}

/* ─────────────────────────────── CBLC ─────────────────────────────── */

void CBDT_CBLC_Rebuilder::rebuildCBLCTable(std::vector<uint8_t>& cblc) {
    appendUInt32(cblc, 0x00020000); // version
    appendUInt32(cblc, static_cast<uint32_t>(strikes.size())); // numStrikes

    std::vector<uint32_t> strikeOffsets(strikes.size(), 0);
    size_t offsetStart = cblc.size();
    cblc.resize(cblc.size() + strikes.size() * 4, 0);

    size_t idx = 0;
    for (const auto& [id, strike] : strikes) {
        strikeOffsets[idx] = cblc.size();
        rebuildStrike(cblc, strike);
        ++idx;
    }

    for (size_t i = 0; i < strikeOffsets.size(); ++i)
        setUInt32(cblc, offsetStart + i * 4, strikeOffsets[i]);
}

void CBDT_CBLC_Rebuilder::rebuildStrike(std::vector<uint8_t>& buf, const StrikeRecord& strike) {
    appendUInt16(buf, strike.ppem);
    appendUInt16(buf, strike.resolution);
    appendUInt32(buf, 0); // colorRef
    appendUInt16(buf, 72);
    appendUInt16(buf, 72);

    uint16_t firstGlyph = 0xFFFF, lastGlyph = 0;
    for (uint16_t g : strike.glyphIDs) {
        if (std::find(removedGlyphs.begin(), removedGlyphs.end(), g) == removedGlyphs.end()) {
            firstGlyph = std::min(firstGlyph, g);
            lastGlyph  = std::max(lastGlyph, g);
        }
    }
    if (firstGlyph == 0xFFFF) firstGlyph = lastGlyph = 0;

    appendUInt16(buf, firstGlyph);
    appendUInt16(buf, lastGlyph);
    appendUInt16(buf, strike.ppem);
    appendUInt16(buf, strike.ppem);
    buf.push_back(1); // bitDepth
    appendUInt16(buf, 0); // flags

    appendUInt32(buf, 0x00000020); // offsetArray (placeholder)
    appendUInt32(buf, 1);          // numSubtables
    appendUInt32(buf, 0);          // colorRef

    rebuildIndexSubtable1(buf, strike, firstGlyph, lastGlyph);
}

void CBDT_CBLC_Rebuilder::rebuildIndexSubtable1(
    std::vector<uint8_t>& buf, const StrikeRecord& strike,
    uint16_t firstGlyph, uint16_t lastGlyph
) {
    appendUInt16(buf, firstGlyph);
    appendUInt16(buf, lastGlyph);
    appendUInt16(buf, 1);   // indexFormat
    appendUInt16(buf, 17);  // imageFormat = PNG(small metrics)
    appendUInt32(buf, 0);   // imageDataOffsetArray offset placeholder

    uint32_t imgDataOffset = 0;
    size_t offsetArrayPos = buf.size();
    for (uint16_t g = firstGlyph; g <= lastGlyph; ++g) {
        if (std::find(removedGlyphs.begin(), removedGlyphs.end(), g) != removedGlyphs.end()) {
            appendUInt32(buf, 0);
            continue;
        }
        auto it = strike.glyphImages.find(g);
        if (it != strike.glyphImages.end() && !it->second.data.empty()) {
            appendUInt32(buf, imgDataOffset);
            imgDataOffset += it->second.data.size();
        } else {
            appendUInt32(buf, 0);
        }
    }
    setUInt32(buf, offsetArrayPos - 4, static_cast<uint32_t>(offsetArrayPos - offsetArrayPos + 4));
}

/* ─────────────────────────────── CBDT ─────────────────────────────── */

void CBDT_CBLC_Rebuilder::rebuildCBDTTable(std::vector<uint8_t>& cbdt) {
    appendUInt32(cbdt, 0x00020000); // version

    for (const auto& [id, strike] : strikes) {
        for (uint16_t g : strike.glyphIDs) {
            if (std::find(removedGlyphs.begin(), removedGlyphs.end(), g) != removedGlyphs.end())
                continue;
            auto it = strike.glyphImages.find(g);
            if (it != strike.glyphImages.end())
                cbdt.insert(cbdt.end(), it->second.data.begin(), it->second.data.end());
        }
    }
}

/* ─────────────────────────────── FONT UPDATE ─────────────────────────────── */

std::vector<uint8_t> CBDT_CBLC_Rebuilder::createUpdatedFont(
    const std::vector<uint8_t>& newCBLCTable,
    const std::vector<uint8_t>& newCBDTTable
) {
    auto tables = parseTTFTables(fontData);
    std::vector<uint8_t> newFont;

    const TTFHeader* header = reinterpret_cast<const TTFHeader*>(fontData.data());
    uint16_t numTables = header->numTables;

    appendUInt32(newFont, header->sfntVersion);
    appendUInt16(newFont, numTables);
    appendUInt16(newFont, header->searchRange);
    appendUInt16(newFont, header->entrySelector);
    appendUInt16(newFont, header->rangeShift);

    size_t dirStart = newFont.size();
    newFont.resize(dirStart + numTables * sizeof(TableRecord));

    size_t currentOffset = 12 + numTables * 16;
    for (size_t i = 0; i < tables.size(); ++i) {
        const TableRecord& t = tables[i];
        std::string tag(t.tag, t.tag + 4);

        std::vector<uint8_t> data;
        if (tag == "CBLC")
            data = newCBLCTable;
        else if (tag == "CBDT")
            data = newCBDTTable;
        else
            data.assign(fontData.begin() + t.offset, fontData.begin() + t.offset + t.length);

        while (data.size() % 4 != 0) data.push_back(0);
        uint32_t checksum = calcTableChecksum(data);

        // Write table record
        setTag(newFont, dirStart + i * 16, tag);
        setUInt32(newFont, dirStart + i * 16 + 4, checksum);
        setUInt32(newFont, dirStart + i * 16 + 8, currentOffset);
        setUInt32(newFont, dirStart + i * 16 + 12, data.size());

        newFont.insert(newFont.end(), data.begin(), data.end());
        currentOffset += data.size();
    }

    // Fix head checksum
    const TableRecord* head = findTable(tables, "head");
    if (head) {
        size_t headOffset = head->offset;
        setUInt32(newFont, headOffset + 8, 0);
        uint32_t total = calcTableChecksum(newFont);
        uint32_t adjust = 0xB1B0AFBA - total;
        setUInt32(newFont, headOffset + 8, adjust);
    }

    std::cout << "[Rebuilder] Created font with "
              << newCBLCTable.size() << " bytes (CBLC) and "
              << newCBDTTable.size() << " bytes (CBDT)\n";

    return newFont;
}

} // namespace fontmaster


--------------------------------

./src/formats/CBDT_CBLC_Font.cpp
#include "fontmaster/CBDT_CBLC_Font.h"
#include "fontmaster/CBDT_CBLC_Rebuilder.h"
#include "fontmaster/TTFUtils.h"
#include <iostream>
#include <fstream>

namespace fontmaster {

CBDT_CBLC_Font::CBDT_CBLC_Font(const std::string& filepath) 
    : filepath(filepath), parser(std::vector<uint8_t>()) {}

bool CBDT_CBLC_Font::load() {
    if (fontData.empty()) {
        std::ifstream file(filepath, std::ios::binary);
        if (!file) {
            return false;
        }
        
        file.seekg(0, std::ios::end);
        size_t size = file.tellg();
        file.seekg(0, std::ios::beg);
        
        fontData.resize(size);
        file.read(reinterpret_cast<char*>(fontData.data()), size);
    }
    
    // Инициализируем парсер с данными шрифта
    parser = CBDT_CBLC_Parser(fontData);
    
    if (!parser.parse()) {
        std::cerr << "Failed to parse CBDT/CBLC font" << std::endl;
        return false;
    }
    
    std::cout << "CBDT/CBLC Font loaded successfully: " << filepath << std::endl;
    return true;
}

bool CBDT_CBLC_Font::save(const std::string& filepath) {
    CBDT_CBLC_Rebuilder rebuilder(fontData, parser.getStrikes(), parser.getRemovedGlyphs());
    std::vector<uint8_t> newData = rebuilder.rebuild();
    
    std::ofstream file(filepath, std::ios::binary);
    if (!file) {
        return false;
    }
    
    file.write(reinterpret_cast<const char*>(newData.data()), newData.size());
    return file.good();
}

const std::vector<uint8_t>& CBDT_CBLC_Font::getFontData() const {
    return fontData;
}

void CBDT_CBLC_Font::setFontData(const std::vector<uint8_t>& data) {
    fontData = data;
}





} // namespace fontmaster

--------------------------------

./src/formats/CBDT_CBLC_Handler.cpp
#include "fontmaster/CBDT_CBLC_Handler.h"
#include "fontmaster/CBDT_CBLC_Font.h"
#include "fontmaster/FontMaster.h"
#include "fontmaster/TTFUtils.h"
#include <iostream>
#include <fstream>

namespace fontmaster {

bool CBDT_CBLC_Handler::canHandle(const std::string& filepath) {
    try {
        std::ifstream file(filepath, std::ios::binary);
        if (!file) return false;

        file.seekg(0, std::ios::end);
        size_t size = file.tellg();
        file.seekg(0, std::ios::beg);
            
        if (size < 1024) return false;
            
        std::vector<uint8_t> header(1024);
        file.read(reinterpret_cast<char*>(header.data()), header.size());
            
        auto tables = utils::parseTTFTables(header);
        bool hasCBDT = utils::hasTable(tables, "CBDT");
        bool hasCBLC = utils::hasTable(tables, "CBLC");
        
        return hasCBDT && hasCBLC;
    } catch (...) {
        return false;
    }
}

std::unique_ptr<Font> CBDT_CBLC_Handler::loadFont(const std::string& filepath) {
    std::ifstream file(filepath, std::ios::binary);
    if (!file) {
        std::cerr << "CBDT/CBLC: Cannot open file: " << filepath << std::endl;
        return nullptr;
    }
    
    file.seekg(0, std::ios::end);
    size_t size = file.tellg();
    file.seekg(0, std::ios::beg);
    
    std::vector<uint8_t> data(size);
    file.read(reinterpret_cast<char*>(data.data()), size);
    
    if (!file) {
        std::cerr << "CBDT/CBLC: Cannot read file: " << filepath << std::endl;
        return nullptr;
    }
    
    if (!canHandle(filepath)) {
        std::cerr << "CBDT/CBLC: Cannot handle this font format" << std::endl;
        return nullptr;
    }
    
    auto font = std::make_unique<CBDT_CBLC_Font>(filepath);
    font->setFontData(data);
    
    if (!font->load()) {
        std::cerr << "CBDT/CBLC: Failed to load font" << std::endl;
        return nullptr;
    }
    
    return font;
}

} // namespace fontmaster

--------------------------------

./src/formats/CBDT_CBLC_Parser.cpp
#include "fontmaster/CBDT_CBLC_Parser.h"
#include "fontmaster/TTFUtils.h"
#include "fontmaster/CMAPParser.h" // если есть
#include <iostream>
#include <algorithm>
#include <cstring>

namespace fontmaster {

CBDT_CBLC_Parser::CBDT_CBLC_Parser(const std::vector<uint8_t>& fontData)
    : fontData(fontData) {}

bool CBDT_CBLC_Parser::parse() {
    using namespace utils;
    try {
        auto tables = parseTTFTables(fontData);

        // Найти CBLC и CBDT записи
        const TableRecord* cblcRec = findTable(tables, "CBLC");
        const TableRecord* cbdtRec = findTable(tables, "CBDT");
        if (!cblcRec || !cbdtRec) {
            std::cerr << "CBDT/CBLC Parser: missing CBLC or CBDT table\n";
            return false;
        }

        // Сохраним оффсеты для последующей работы
        uint32_t cblcOffset = cblcRec->offset;
        uint32_t cblcLength = cblcRec->length;
        cbdtTableOffset = cbdtRec->offset;
        cbdtTableLength = cbdtRec->length;

        if (!parseCBLCTable(cblcOffset, cblcLength)) {
            std::cerr << "CBDT/CBLC Parser: parseCBLCTable failed\n";
            return false;
        }

        if (!parseCBDTTable(cbdtTableOffset, cbdtTableLength)) {
            std::cerr << "CBDT/CBLC Parser: parseCBDTTable failed\n";
            return false;
        }

        // Попытка разобрать cmap для определения удалённых глифов (если таблица cmap есть)
        const TableRecord* cmapRec = findTable(tables, "cmap");
        if (cmapRec) {
            parseCMAPTable(cmapRec->offset, cmapRec->length);
        }

        std::cout << "CBDT/CBLC Parser: parsed strikes=" << strikes.size()
                  << ", removedGlyphs=" << removedGlyphs.size() << std::endl;
        return true;

    } catch (const std::exception& ex) {
        std::cerr << "CBDT/CBLC Parser exception: " << ex.what() << std::endl;
        return false;
    }
}

/* ---------- CBLC parsing ---------- */

bool CBDT_CBLC_Parser::parseCBLCTable(uint32_t offset, uint32_t length) {
    if (offset + 8 > fontData.size()) {
        std::cerr << "CBLC: table out of bounds\n";
        return false;
    }

    const uint8_t* base = fontData.data() + offset;
    uint32_t version = readUInt32(base);
    uint32_t numStrikes = readUInt32(base + 4);

    // Смещения массива strikeOffsets начинаются в base+8
    uint32_t strikeArrayPos = offset + 8;
    for (uint32_t i = 0; i < numStrikes; ++i) {
        if (strikeArrayPos + i * 4 + 4 > fontData.size()) break;
        const uint8_t* p = fontData.data() + strikeArrayPos + i * 4;
        uint32_t strikeOffset = readUInt32(p);
        if (offset + strikeOffset >= fontData.size()) continue;
        if (!parseStrike(offset + strikeOffset, i)) {
            std::cerr << "CBLC: failed parseStrike index=" << i << std::endl;
            // не прерываем весь разбор — пропускаем ошибочные страйки
            continue;
        }
    }
    return true;
}

bool CBDT_CBLC_Parser::parseStrike(uint32_t offset, uint32_t strikeIndex) {
    if (offset + 32 > fontData.size()) return false;
    const uint8_t* data = fontData.data() + offset;

    StrikeRecord strike;
    strike.ppem = readUInt16(data + 0);
    strike.resolution = readUInt16(data + 2);

    // startGlyphIndex / endGlyphIndex расположены чаще всего позже — попробуем безопасно прочитать
    uint16_t startGlyphIndex = readUInt16(data + 12);
    uint16_t endGlyphIndex = readUInt16(data + 14);

    // numberOfIndexSubTables и offset к ним
    uint32_t indexSubtableArrayOffset = readUInt32(data + 24);
    uint32_t numberOfIndexSubTables = readUInt32(data + 28);

    // Обходим indexSubtableArray
    uint32_t indexSubtableArrayPos = offset + indexSubtableArrayOffset;
    for (uint32_t i = 0; i < numberOfIndexSubTables; ++i) {
        if (indexSubtableArrayPos + i * 8 + 8 > fontData.size()) break;
        const uint8_t* entry = fontData.data() + indexSubtableArrayPos + i * 8;
        uint16_t firstGlyph = readUInt16(entry + 0);
        uint16_t lastGlyph  = readUInt16(entry + 2);
        uint32_t additionalOffset = readUInt32(entry + 4);
        uint32_t subtableOffset = offset + indexSubtableArrayOffset + additionalOffset;
        if (subtableOffset >= fontData.size()) continue;

        // Для всех glyphID в этом диапазоне мы добавим их в список glyphIDs и попытаемся распарсить субтаблицу
        for (uint16_t gid = firstGlyph; gid <= lastGlyph; ++gid) {
            strike.glyphIDs.push_back(gid);
        }

        if (!parseIndexSubtable(subtableOffset, strike)) {
            std::cerr << "CBLC: parseIndexSubtable failed at offset " << subtableOffset << std::endl;
            // продолжаем, возможно в других сабтаблицах есть данные
        }
    }

    strikes[strikeIndex] = std::move(strike);
    return true;
}

bool CBDT_CBLC_Parser::parseIndexSubtable(uint32_t offset, StrikeRecord& strike) {
    if (offset + 8 > fontData.size()) return false;
    const uint8_t* p = fontData.data() + offset;

    uint16_t indexFormat = readUInt16(p);
    uint16_t imageFormat = readUInt16(p + 2);
    uint32_t imageDataOffset = readUInt32(p + 4);

    switch (indexFormat) {
        case 1: return parseIndexFormat1(offset, strike,
                                         /*firstGlyph*/ 0, /*lastGlyph*/ 0,
                                         imageFormat, imageDataOffset);
        case 2: return parseIndexFormat2(offset, strike,
                                         /*firstGlyph*/ 0, /*lastGlyph*/ 0,
                                         imageFormat, imageDataOffset);
        case 5: return parseIndexFormat5(offset, strike,
                                         /*firstGlyph*/ 0, /*lastGlyph*/ 0,
                                         imageFormat, imageDataOffset);
        default:
            // Неподдерживаемые форматы - возвращаем true чтобы не ломать общий разбор
            std::cout << "CBLC: Unsupported indexFormat " << indexFormat << std::endl;
            return true;
    }
}

/* indexFormat 1:
   at subtable offset:
   uint16 indexFormat
   uint16 imageFormat
   uint32 imageDataOffset
   uint8 imageSize
   int8 bigMetrics
   int8 bearingX
   int8 bearingY
   uint8 advance
   uint32 glyphOffsets[] (for first..last)
*/
bool CBDT_CBLC_Parser::parseIndexFormat1(uint32_t offset, StrikeRecord& strike,
                                         uint16_t /*firstGlyph*/, uint16_t /*lastGlyph*/,
                                         uint16_t imageFormat, uint32_t imageDataOffset) {
    if (offset + 8 + 5 > fontData.size()) return false;
    const uint8_t* p = fontData.data() + offset + 8;

    uint8_t imageSize = p[0];
    int8_t bigMetrics = static_cast<int8_t>(p[1]);
    int8_t bearingX = static_cast<int8_t>(p[2]);
    int8_t bearingY = static_cast<int8_t>(p[3]);
    uint8_t advance = p[4];

    size_t glyphDataOffset = offset + 8 + 5;
    // glyphOffsets array length = number of glyphs in range (we don't have explicit first/last here,
    // но они были добавлены ранее при чтении indexSubtableArray; поэтому безопасно пробегаем strike.glyphIDs)
    for (size_t i = 0; i < strike.glyphIDs.size(); ++i) {
        uint16_t gid = strike.glyphIDs[i];
        if (glyphDataOffset + 4 > fontData.size()) break;
        uint32_t glyphImageOffset = readUInt32(fontData.data() + glyphDataOffset);

        GlyphImage img;
        img.glyphID = gid;
        img.imageFormat = imageFormat;
        img.offset = imageDataOffset + glyphImageOffset;
        img.bearingX = bearingX;
        img.bearingY = bearingY;
        img.advance = advance;

        if (bigMetrics) {
            img.width = imageSize;
            img.height = imageSize;
        } else {
            img.width = static_cast<uint16_t>((imageSize + 7) / 8);
            img.height = imageSize;
        }

        // сохраняем; данные будем извлекать позже при разборе CBDT
        strike.glyphImages[gid] = std::move(img);
        glyphDataOffset += 4;
    }
    return true;
}

/* indexFormat 2:
   contains per-glyph records (offset, size, maybe bigMetrics fields)
*/
bool CBDT_CBLC_Parser::parseIndexFormat2(uint32_t offset, StrikeRecord& strike,
                                         uint16_t /*firstGlyph*/, uint16_t /*lastGlyph*/,
                                         uint16_t imageFormat, uint32_t imageDataOffset) {
    uint32_t glyphDataOffset = offset + 8;
    size_t i = 0;
    while (i < strike.glyphIDs.size()) {
        if (glyphDataOffset + 6 > fontData.size()) break;
        const uint8_t* p = fontData.data() + glyphDataOffset;
        uint32_t glyphImageOffset = readUInt32(p);
        uint8_t imageSize = p[4];
        int8_t bigMetrics = static_cast<int8_t>(p[5]);

        GlyphImage img;
        img.glyphID = strike.glyphIDs[i];
        img.imageFormat = imageFormat;
        img.offset = imageDataOffset + glyphImageOffset;

        if (bigMetrics) {
            if (glyphDataOffset + 16 > fontData.size()) break;
            img.width = readUInt16(fontData.data() + glyphDataOffset + 6);
            img.height = readUInt16(fontData.data() + glyphDataOffset + 8);
            img.bearingX = static_cast<int16_t>(readUInt16(fontData.data() + glyphDataOffset + 10));
            img.bearingY = static_cast<int16_t>(readUInt16(fontData.data() + glyphDataOffset + 12));
            img.advance = readUInt16(fontData.data() + glyphDataOffset + 14);
            glyphDataOffset += 16;
        } else {
            if (glyphDataOffset + 9 > fontData.size()) break;
            img.width = imageSize;
            img.height = imageSize;
            img.bearingX = static_cast<int8_t>(fontData[glyphDataOffset + 6]);
            img.bearingY = static_cast<int8_t>(fontData[glyphDataOffset + 7]);
            img.advance = fontData[glyphDataOffset + 8];
            glyphDataOffset += 9;
        }

        strike.glyphImages[img.glyphID] = std::move(img);
        ++i;
    }
    return true;
}

/* indexFormat 5:
   first a list of glyphIDs, then offsets for each glyph
*/
bool CBDT_CBLC_Parser::parseIndexFormat5(uint32_t offset, StrikeRecord& strike,
                                         uint16_t /*firstGlyph*/, uint16_t /*lastGlyph*/,
                                         uint16_t imageFormat, uint32_t imageDataOffset) {
    uint32_t glyphDataOffset = offset + 8;
    // Читаем numGlyphs равный количеству glyphIDs в диапазоне
    size_t numGlyphs = strike.glyphIDs.size();
    std::vector<uint16_t> glyphIDs;
    glyphIDs.reserve(numGlyphs);
    for (size_t i = 0; i < numGlyphs; ++i) {
        if (glyphDataOffset + 2 > fontData.size()) break;
        uint16_t gid = readUInt16(fontData.data() + glyphDataOffset);
        glyphIDs.push_back(gid);
        glyphDataOffset += 2;
    }
    // Затем идут offsets
    for (size_t i = 0; i < glyphIDs.size(); ++i) {
        if (glyphDataOffset + 4 > fontData.size()) break;
        uint32_t glyphImageOffset = readUInt32(fontData.data() + glyphDataOffset);
        GlyphImage img;
        img.glyphID = glyphIDs[i];
        img.imageFormat = imageFormat;
        img.offset = imageDataOffset + glyphImageOffset;
        // остальное неизвестно — будет заполнено при extract
        strike.glyphImages[img.glyphID] = std::move(img);
        glyphDataOffset += 4;
    }
    return true;
}

/* ---------- CBDT parsing: извлечение данных изображений ---------- */

bool CBDT_CBLC_Parser::parseCBDTTable(uint32_t offset, uint32_t length) {
    if (offset + 4 > fontData.size()) {
        std::cerr << "CBDT: table too small\n";
        return false;
    }
    const uint8_t* base = fontData.data() + offset;
    uint32_t version = readUInt32(base);
    // Проходим по всем страйкам и их glyphImages и извлекаем данные
    for (auto& strikePair : strikes) {
        StrikeRecord& strike = strikePair.second;
        for (auto& gpair : strike.glyphImages) {
            GlyphImage& gi = gpair.second;
            // gi.offset — относительно начала CBDT (по спецификации imageDataOffset + glyphOffset)
            if (!extractGlyphImageData(gi.offset, gi, offset, length)) {
                // Если извлечение не удалось — ставим пустые данные, но не фатальная ошибка
                std::cerr << "CBDT: failed to extract image for glyph " << gi.glyphID << std::endl;
                continue;
            }
        }
    }
    return true;
}

bool CBDT_CBLC_Parser::extractGlyphImageData(uint32_t imageOffset, GlyphImage& image, uint32_t cbdtBase, uint32_t cbdtLength) {
    // imageOffset — смещение от начала CBDT таблицы
    if (cbdtBase + imageOffset >= fontData.size()) return false;
    const uint8_t* data = fontData.data() + cbdtBase + imageOffset;
    size_t available = static_cast<size_t>(std::min<uint32_t>(fontData.size() - (cbdtBase + imageOffset), cbdtLength));

    // Попробуем угадать формат по image.imageFormat
    switch (image.imageFormat) {
        case 1: case 2: case 3: case 4: case 8: case 9:
            return extractBitmapData(data, available, image);
        case 5: case 17: case 18:
            return extractPNGData(data, available, image);
        case 6:
            return extractJPEGData(data, available, image);
        case 7:
            return extractTIFFData(data, available, image);
        default:
            // Эвристики: если начинается с PNG сигнатуры — PNG, если 0xFF 0xD8 — JPEG, иначе bitmap
            if (available >= 8 && data[0] == 0x89 && data[1] == 0x50 && data[2] == 0x4E && data[3] == 0x47) {
                return extractPNGData(data, available, image);
            }
            if (available >= 2 && data[0] == 0xFF && data[1] == 0xD8) {
                return extractJPEGData(data, available, image);
            }
            return extractBitmapData(data, available, image);
    }
}

bool CBDT_CBLC_Parser::extractBitmapData(const uint8_t* data, size_t available, GlyphImage& image) {
    // Для простоты берем весь доступный кусок (эвристика). В rebuilder-е мы будем просто склеивать данные.
    size_t copyLen = available;
    if (copyLen == 0) return false;
    image.data.assign(data, data + copyLen);
    image.length = static_cast<uint32_t>(copyLen);
    return true;
}

bool CBDT_CBLC_Parser::extractPNGData(const uint8_t* data, size_t available, GlyphImage& image) {
    // Найдём IEND chunk. Проверяем наличие сигнатуры PNG в начале
    if (available < 8) return false;
    // PNG сигнатура 8 байт
    if (!(data[0] == 0x89 && data[1] == 0x50 && data[2] == 0x4E && data[3] == 0x47 &&
          data[4] == 0x0D && data[5] == 0x0A && data[6] == 0x1A && data[7] == 0x0A)) {
        // не PNG
        return false;
    }
    // Ищем "IEND" + 4 байта CRC после
    const uint8_t* cur = data;
    const uint8_t* end = data + available;
    while (cur + 8 <= end) {
        if (cur[1] == 'I' && cur[2] == 'E' && cur[3] == 'N' && cur[4] == 'D') {
            // смещение до "IEND" найдено (предполагаем, что перед ним находится длина/chunk)
            size_t iendPos = cur - data;
            size_t total = iendPos + 8; // "IEND" chunk 4 bytes tag + 4 bytes CRC (+ preceding length not considered)
            if (total > available) total = available;
            image.data.assign(data, data + total);
            image.length = static_cast<uint32_t>(image.data.size());
            return true;
        }
        ++cur;
    }
    // fallback: просто возьмём максимум до доступного
    image.data.assign(data, data + available);
    image.length = static_cast<uint32_t>(available);
    return true;
}

bool CBDT_CBLC_Parser::extractJPEGData(const uint8_t* data, size_t available, GlyphImage& image) {
    // ищем EOI 0xFF 0xD9
    const uint8_t* cur = data;
    const uint8_t* end = data + available;
    while (cur + 2 <= end) {
        if (cur[0] == 0xFF && cur[1] == 0xD9) {
            size_t len = (cur + 2) - data;
            image.data.assign(data, data + len);
            image.length = static_cast<uint32_t>(len);
            return true;
        }
        ++cur;
    }
    image.data.assign(data, data + available);
    image.length = static_cast<uint32_t>(available);
    return true;
}

bool CBDT_CBLC_Parser::extractTIFFData(const uint8_t* data, size_t available, GlyphImage& image) {
    if (available < 8) return false;
    bool bigEndian = (data[0] == 'M' && data[1] == 'M');
    // Проверка сигнатуры TIFF (II -> 0x49 0x49, MM -> 0x4D 0x4D)
    if (!((!bigEndian && data[0] == 0x49 && data[1] == 0x49) || (bigEndian && data[0] == 0x4D && data[1] == 0x4D))) {
        return false;
    }
    uint32_t ifdOffset = readUInt32(data + 4, bigEndian);
    if (!parseTIFFDirectory(data, available, ifdOffset, image, bigEndian)) {
        // fallback: берем весь доступный кусок
        image.data.assign(data, data + available);
        image.length = static_cast<uint32_t>(available);
        return true;
    }
    // если parseTIFFDirectory не сохранил данные — сохраняем весь блок
    if (image.data.empty()) {
        image.data.assign(data, data + available);
        image.length = static_cast<uint32_t>(available);
    }
    return true;
}

bool CBDT_CBLC_Parser::parseTIFFDirectory(const uint8_t* data, size_t available, uint32_t ifdOffset, GlyphImage& image, bool bigEndian) {
    if (ifdOffset + 2 > available) return false;
    const uint8_t* dir = data + ifdOffset;
    uint16_t entryCount = readUInt16(dir, bigEndian);
    if (ifdOffset + 2 + entryCount * 12 > available) return false;

    // Минимально извлечём некоторые теги: width/height/strip offsets/byte counts
    struct TIFFInfo {
        uint32_t imageWidth = 0, imageHeight = 0;
        uint32_t stripOffset = 0, stripByteCount = 0;
        uint16_t bitsPerSample = 1;
        uint16_t compression = 1;
        double xRes = 72.0, yRes = 72.0;
    } info;

    for (uint16_t i = 0; i < entryCount; ++i) {
        const uint8_t* entry = dir + 2 + i * 12;
        uint16_t tag = readUInt16(entry, bigEndian);
        uint16_t type = readUInt16(entry + 2, bigEndian);
        uint32_t count = readUInt32(entry + 4, bigEndian);
        uint32_t valueOffset = readUInt32(entry + 8, bigEndian);

        // Простая поддержка нужных тегов
        switch (tag) {
            case 256: // ImageWidth
                if (type == 3) info.imageWidth = valueOffset;
                break;
            case 257: // ImageLength
                if (type == 3) info.imageHeight = valueOffset;
                break;
            case 273: // StripOffsets
                info.stripOffset = valueOffset;
                break;
            case 279: // StripByteCounts
                info.stripByteCount = valueOffset;
                break;
            case 282: // XResolution (RATIONAL)
                // пропускаем для простоты
                break;
            case 283: // YResolution
                break;
            default:
                break;
        }
    }

    // Если есть stripOffset/byteCount — попытаемся вырезать кусок
    if (info.stripOffset && info.stripByteCount && info.stripOffset + info.stripByteCount <= available) {
        image.data.assign(data + info.stripOffset, data + info.stripOffset + info.stripByteCount);
        image.length = info.stripByteCount;
        if (info.imageWidth) image.width = static_cast<uint16_t>(info.imageWidth);
        if (info.imageHeight) image.height = static_cast<uint16_t>(info.imageHeight);
        return true;
    }

    return false;
}

/* ---------- CMAP parsing (опционально) ---------- */

bool CBDT_CBLC_Parser::parseCMAPTable(uint32_t offset, uint32_t length) {
    // Пробуем использовать utils::CMAPParser, если он есть
    try {
        std::vector<uint8_t> cmapData(fontData.begin() + offset, fontData.begin() + offset + length);
        utils::CMAPParser cmapParser(cmapData);
        if (!cmapParser.parse()) return false;

        auto glyphToCharMap = cmapParser.getGlyphToCharMap();
        // Для каждого страйка: если glyphID не содержит отображения в cmap -> считаем удалённым
        for (const auto& s : strikes) {
            for (uint16_t gid : s.second.glyphIDs) {
                if (glyphToCharMap.find(gid) == glyphToCharMap.end() ||
                    glyphToCharMap.at(gid).empty()) {
                    if (std::find(removedGlyphs.begin(), removedGlyphs.end(), gid) == removedGlyphs.end())
                        removedGlyphs.push_back(gid);
                }
            }
        }
        return true;
    } catch (...) {
        // если нет CMAPParser или он упал — просто возвращаем false, это не фатально
        return false;
    }
}

/* ---------- helpers ---------- */

uint32_t CBDT_CBLC_Parser::readUInt32(const uint8_t* p) const {
    return (uint32_t(p[0]) << 24) | (uint32_t(p[1]) << 16) | (uint32_t(p[2]) << 8) | uint32_t(p[3]);
}

uint16_t CBDT_CBLC_Parser::readUInt16(const uint8_t* p) const {
    return (uint16_t(p[0]) << 8) | uint16_t(p[1]);
}

uint16_t CBDT_CBLC_Parser::readUInt16(const uint8_t* p, bool bigEndian) const {
    if (bigEndian) return (uint16_t(p[0]) << 8) | uint16_t(p[1]);
    return (uint16_t(p[1]) << 8) | uint16_t(p[0]);
}

uint32_t CBDT_CBLC_Parser::readUInt32(const uint8_t* p, bool bigEndian) const {
    if (bigEndian) return (uint32_t(p[0]) << 24) | (uint32_t(p[1]) << 16) | (uint32_t(p[2]) << 8) | uint32_t(p[3]);
    return (uint32_t(p[3]) << 24) | (uint32_t(p[2]) << 16) | (uint32_t(p[1]) << 8) | uint32_t(p[0]);
}

} // namespace fontmaster

--------------------------------

./src/formats/SVG_Handler.cpp
#include "fontmaster/FontMaster.h"
#include "fontmaster/TTFUtils.h"

namespace fontmaster {

class SVG_Handler : public FontFormatHandler {
public:
    bool canHandle(const std::string& filepath) override {
        try {
            std::ifstream file(filepath, std::ios::binary);
            if (!file) return false;
            
            file.seekg(0, std::ios::end);
            size_t size = file.tellg();
            file.seekg(0, std::ios::beg);
            
            if (size < 1024) return false;
            
            std::vector<uint8_t> header(1024);
            file.read(reinterpret_cast<char*>(header.data()), header.size());
            
            auto tables = utils::parseTTFTables(header);
            return utils::hasTable(tables, "SVG ");
        } catch (...) {
            return false;
        }
    }
    
    std::unique_ptr<Font> loadFont(const std::string& filepath) override {
        return std::make_unique<SVG_Font>(filepath);
    }
    
    FontFormat getFormat() const override { return FontFormat::SVG; }
};

class SVG_Font : public Font {
private:
    std::string filepath;
    std::vector<uint8_t> fontData;
    std::map<std::string, std::string> glyphSVG;
    std::vector<std::string> removedGlyphs;
    
public:
    SVG_Font(const std::string& path) : filepath(path) {
        loadFontData();
        parseFont();
    }
    
private:
    void loadFontData() {
        std::ifstream file(filepath, std::ios::binary);
        if (!file) {
            throw FontLoadException(filepath, "Cannot open file");
        }
        
        file.seekg(0, std::ios::end);
        size_t size = file.tellg();
        file.seekg(0, std::ios::beg);
        
        fontData.resize(size);
        if (!file.read(reinterpret_cast<char*>(fontData.data()), size)) {
            throw FontLoadException(filepath, "Cannot read file data");
        }
    }
    
    void parseFont() {
        auto tables = utils::parseTTFTables(fontData);
        if (!utils::hasTable(tables, "SVG ")) {
            throw FontFormatException("SVG", "SVG table not found");
        }
        
        std::cout << "SVG table found" << std::endl;
        
        // Заглушка для демонстрации
        for (int i = 0; i < 10; ++i) {
            std::string glyphName = "svg_glyph_" + std::to_string(i);
            glyphSVG[glyphName] = "<svg><circle cx='50' cy='50' r='40'/></svg>";
        }
    }
    
public:
    FontFormat getFormat() const override { return FontFormat::SVG; }
    
    bool removeGlyph(const std::string& glyphName) override {
        auto it = glyphSVG.find(glyphName);
        if (it == glyphSVG.end()) {
            return false;
        }
        
        glyphSVG.erase(it);
        removedGlyphs.push_back(glyphName);
        return true;
    }
    
    bool removeGlyph(uint32_t unicode) override {
        std::string name = findGlyphName(unicode);
        if (name.empty()) return false;
        return removeGlyph(name);
    }
    
    bool replaceGlyphImage(const std::string& glyphName,
                          const std::vector<uint8_t>& newImage) override {
        auto it = glyphSVG.find(glyphName);
        if (it == glyphSVG.end()) {
            return false;
        }
        
        std::string newSVG(newImage.begin(), newImage.end());
        it->second = newSVG;
        return true;
    }
    
    std::vector<GlyphInfo> listGlyphs() const override {
        std::vector<GlyphInfo> result;
        for (const auto& pair : glyphSVG) {
            if (std::find(removedGlyphs.begin(), removedGlyphs.end(), pair.first) != removedGlyphs.end()) {
                continue;
            }
            
            GlyphInfo info;
            info.name = pair.first;
            info.format = "svg";
            const std::string& svg = pair.second;
            info.image_data.assign(svg.begin(), svg.end());
            info.data_size = svg.size();
            result.push_back(info);
        }
        return result;
    }
    
    GlyphInfo getGlyphInfo(const std::string& glyphName) const override {
        auto it = glyphSVG.find(glyphName);
        if (it != glyphSVG.end()) {
            GlyphInfo info;
            info.name = glyphName;
            info.format = "svg";
            const std::string& svg = it->second;
            info.image_data.assign(svg.begin(), svg.end());
            info.data_size = svg.size();
            return info;
        }
        throw GlyphNotFoundException(glyphName);
    }
    
    std::string findGlyphName(uint32_t unicode) const override {
        // Для SVG нужно парсить cmap таблицу
        // Временно возвращаем пустую строку
        return "";
    }
    
    bool save(const std::string& outputPath) override {
        try {
            std::ofstream file(outputPath, std::ios::binary);
            if (!file) {
                throw FontSaveException(outputPath, "Cannot create output file");
            }
            
            file.write(reinterpret_cast<const char*>(fontData.data()), fontData.size());
            return file.good();
        } catch (const std::exception& e) {
            throw FontSaveException(outputPath, std::string("Save failed: ") + e.what());
        }
    }
};

static bool registerSVGHandler() {
    FontMasterImpl::instance().registerHandler(
        std::make_unique<SVG_Handler>()
    );
    return true;
}

static bool svgHandlerRegistered = registerSVGHandler();

} // namespace fontmaster

--------------------------------

./src/formats/CBDT_CBLC_Registration.cpp
#include "fontmaster/CBDT_CBLC_Handler.h"
#include "fontmaster/FontMasterImpl.h"

namespace fontmaster {

bool registerCBDTHandler() {
    FontMaster::instance().registerHandler(
        std::make_unique<CBDT_CBLC_Handler>()
    );
    return true;
}

// Автоматическая регистрация при загрузке библиотеки
static bool registered = registerCBDTHandler();

} // namespace fontmaster

--------------------------------

./allfiles.txt

--------------------------------

./CMakeLists.txt
cmake_minimum_required(VERSION 3.10)
project(fontmaster VERSION 1.0.0 LANGUAGES CXX)

# Set C++ standard
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Compiler warnings
if(CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra -Wpedantic")
elseif(MSVC)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /W4")
endif()

# Include directories
include_directories(include)

# Core library sources
set(CORE_SOURCES
    src/core/FontMaster.cpp
    src/core/FontRegistry.cpp
)

# Utils sources
set(UTILS_SOURCES
    src/utils/CFFParser.cpp
    src/utils/CMAPParser.cpp
    src/utils/MAXPParser.cpp
    src/utils/NAMEParser.cpp
    src/utils/POSTParser.cpp
    src/utils/TTFRebuilder.cpp
    src/utils/TTFUtils.cpp
)

# Format handlers sources
set(FORMATS_SOURCES
    src/formats/CBDT_CBLC_Font.cpp
    src/formats/CBDT_CBLC_Handler.cpp
    src/formats/CBDT_CBLC_Parser.cpp
    src/formats/CBDT_CBLC_Rebuilder.cpp
    src/formats/CBDT_CBLC_Registration.cpp
    src/formats/COLR_CPAL_Handler.cpp
    src/formats/SBIX_Handler.cpp
    src/formats/SVG_Handler.cpp
)

# Combine all sources
set(ALL_SOURCES
    ${CORE_SOURCES}
    ${UTILS_SOURCES}
    ${FORMATS_SOURCES}
)

# Create main library
add_library(fontmaster SHARED ${ALL_SOURCES})

# Include directories for the library
target_include_directories(fontmaster 
    PUBLIC 
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
        $<INSTALL_INTERFACE:include>
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/src
)

# Set library properties
set_target_properties(fontmaster PROPERTIES
    VERSION ${PROJECT_VERSION}
    SOVERSION 1
    OUTPUT_NAME "fontmaster"
)

# CLI executable
add_executable(fontmaster_cli
    src/cli/main.cpp
    src/cli/CommandProcessor.cpp
)

target_link_libraries(fontmaster_cli fontmaster)

# Qt GUI executable (optional - requires Qt)
find_package(Qt5 COMPONENTS Core Widgets QUIET)
if(Qt5_FOUND)
    qt5_wrap_cpp(QT_HEADERS
        src/qt/MainWindow.h
    )
    
    add_executable(fontmaster_qt
        src/qt/main.cpp
        src/qt/MainWindow.cpp
        ${QT_HEADERS}
    )
    
    target_link_libraries(fontmaster_qt fontmaster Qt5::Core Qt5::Widgets)
    
    # Set Qt specific properties
    set_target_properties(fontmaster_qt PROPERTIES
        CXX_STANDARD 17
        CXX_STANDARD_REQUIRED ON
    )
else()
    message(WARNING "Qt5 not found - skipping fontmaster_qt target")
endif()

# Tests (optional)
if(EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/tests/test_cbdt_cblc.cpp")
    enable_testing()
    
    add_executable(fontmaster_tests
        tests/test_cbdt_cblc.cpp
    )
    
    target_link_libraries(fontmaster_tests fontmaster)
    
    add_test(NAME CBDT_CBLCTests COMMAND fontmaster_tests)
endif()

# Installation
install(TARGETS fontmaster fontmaster_cli
    ARCHIVE DESTINATION lib
    LIBRARY DESTINATION lib
    RUNTIME DESTINATION bin
)

if(TARGET fontmaster_qt)
    install(TARGETS fontmaster_qt
        RUNTIME DESTINATION bin
    )
endif()

install(DIRECTORY include/fontmaster
    DESTINATION include
)

# Package configuration (optional)
#include(CMakePackageConfigHelpers)

#write_basic_package_version_file(
#    "${CMAKE_CURRENT_BINARY_DIR}/fontmaster-config-version.cmake"
#    VERSION ${PROJECT_VERSION}
#    COMPATIBILITY AnyNewerVersion
#)

#configure_package_config_file(
#    ${CMAKE_CURRENT_SOURCE_DIR}/cmake/fontmaster-config.cmake.in
#    ${CMAKE_CURRENT_BINARY_DIR}/fontmaster-config.cmake
#    INSTALL_DESTINATION lib/cmake/fontmaster
#)

#install(FILES
#    ${CMAKE_CURRENT_BINARY_DIR}/fontmaster-config.cmake
#    ${CMAKE_CURRENT_BINARY_DIR}/fontmaster-config-version.cmake
#    DESTINATION lib/cmake/fontmaster
#)

# Export targets
#export(EXPORT fontmaster-targets
#    FILE "${CMAKE_CURRENT_BINARY_DIR}/fontmaster-targets.cmake"
#)

#install(EXPORT fontmaster-targets
#    FILE fontmaster-targets.cmake
#    DESTINATION lib/cmake/fontmaster
#)

--------------------------------

./all.sh
#!/bin/bash

for name in $(find . -type f); do
    if [ $name -eq "allfiles.txt" ] ; then
        continue
    fi
    echo $name
    cat $name
    echo -e "\n--------------------------------\n"
done

--------------------------------

./tests/test_cbdt_cblc.cpp
#include "fontmaster/FontMaster.h"
#include <cassert>
#include <iostream>

void testCBDParsing() {
    std::cout << "Testing CBDT/CBLC parsing..." << std::endl;
    
    try {
        auto font = fontmaster::Font::load("test_emoji.ttf");
        assert(font != nullptr);
        assert(font->getFormat() == fontmaster::FontFormat::CBDT_CBLC);
        
        auto glyphs = font->listGlyphs();
        assert(!glyphs.empty());
        
        std::cout << "✓ CBDT/CBLC parsing test passed" << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "✗ CBDT/CBLC parsing test failed: " << e.what() << std::endl;
        throw;
    }
}

void testGlyphRemoval() {
    std::cout << "Testing glyph removal..." << std::endl;
    
    try {
        auto font = fontmaster::Font::load("test_emoji.ttf");
        auto originalGlyphs = font->listGlyphs();
        
        if (!originalGlyphs.empty()) {
            const std::string testGlyph = originalGlyphs[0].name;
            bool removed = font->removeGlyph(testGlyph);
            assert(removed);
            
            auto newGlyphs = font->listGlyphs();
            assert(newGlyphs.size() == originalGlyphs.size() - 1);
            
            // Проверяем, что глиф действительно удален
            bool found = false;
            for (const auto& glyph : newGlyphs) {
                if (glyph.name == testGlyph) {
                    found = true;
                    break;
                }
            }
            assert(!found);
        }
        
        std::cout << "✓ Glyph removal test passed" << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "✗ Glyph removal test failed: " << e.what() << std::endl;
        throw;
    }
}

int main() {
    try {
        testCBDParsing();
        testGlyphRemoval();
        std::cout << "All tests passed!" << std::endl;
        return 0;
    } catch (...) {
        return 1;
    }
}

--------------------------------

./include/fontmaster/CFFParser.h
#ifndef CFFPARSER_H
#define CFFPARSER_H

#include <vector>
#include <cstdint>

namespace fontmaster {
namespace utils {

class CFFParser {
public:
    CFFParser(const std::vector<uint8_t>& data, uint32_t offset = 0);
    
    bool parse();
    
private:
    std::vector<uint8_t> fontData;
    uint32_t baseOffset;

    bool parseIndex(size_t& offset);
    uint32_t readOffset(const uint8_t* data, uint8_t offSize);
};

} // namespace utils
} // namespace fontmaster

#endif // CFFPARSER_H

--------------------------------

./include/fontmaster/CBDT_CBLC_Font.h
#ifndef CBDT_CBLC_FONT_H
#define CBDT_CBLC_FONT_H

#include "fontmaster/FontMaster.h"
#include "fontmaster/CBDT_CBLC_Parser.h"
#include <string>
#include <vector>

namespace fontmaster {

class CBDT_CBLC_Font : public Font {
public:
    CBDT_CBLC_Font(const std::string& filepath);
    virtual ~CBDT_CBLC_Font() = default;
    
    bool load() override;
    bool save(const std::string& filepath) override;
    
    const std::vector<uint8_t>& getFontData() const override;
    void setFontData(const std::vector<uint8_t>& data) override;
    
    // CBDT/CBLC specific methods
    const std::map<uint32_t, StrikeRecord>& getStrikes() const { return parser.getStrikes(); }
    const std::vector<uint16_t>& getRemovedGlyphs() const { return parser.getRemovedGlyphs(); }
    
private:
    std::string filepath;
    std::vector<uint8_t> fontData;
    CBDT_CBLC_Parser parser;
};

} // namespace fontmaster

#endif // CBDT_CBLC_FONT_H

--------------------------------

./include/fontmaster/CMAPParser.h
#ifndef CMAPPARSER_H
#define CMAPPARSER_H

#include <vector>
#include <map>
#include <set>
#include <cstdint>
#include <string>

namespace fontmaster {
namespace utils {

class CMAPParser {
public:
    CMAPParser(const std::vector<uint8_t>& fontData);
    
    bool parse();
    
    uint16_t getGlyphIndex(uint32_t charCode) const;
    std::set<uint32_t> getCharCodes(uint16_t glyphIndex) const;
    const std::map<uint32_t, uint16_t>& getCharToGlyphMap() const { return charToGlyph; }
    const std::map<uint16_t, std::set<uint32_t>>& getGlyphToCharMap() const { return glyphToChar; }

private:
    std::vector<uint8_t> fontData;
    std::map<uint32_t, uint16_t> charToGlyph;
    std::map<uint16_t, std::set<uint32_t>> glyphToChar;

    void parseSubtable(uint32_t offset, uint16_t platformID, uint16_t encodingID);
    void parseFormat0(uint32_t offset, uint16_t platformID, uint16_t encodingID);
    void parseFormat2(uint32_t offset, uint16_t platformID, uint16_t encodingID);
    void parseFormat4(uint32_t offset, uint16_t platformID, uint16_t encodingID);
    void parseFormat6(uint32_t offset, uint16_t platformID, uint16_t encodingID);
    void parseFormat8(uint32_t offset, uint16_t platformID, uint16_t encodingID);
    void parseFormat10(uint32_t offset, uint16_t platformID, uint16_t encodingID);
    void parseFormat12(uint32_t offset, uint16_t platformID, uint16_t encodingID);
    void parseFormat13(uint32_t offset, uint16_t platformID, uint16_t encodingID);
    void parseFormat14(uint32_t offset, uint16_t platformID, uint16_t encodingID);
    
    uint16_t readUInt16(const uint8_t* data);
    uint32_t readUInt32(const uint8_t* data);
    int16_t readInt16(const uint8_t* data);
};

} // namespace utils
} // namespace fontmaster

#endif // CMAPPARSER_H

--------------------------------

./include/fontmaster/POSTParser.h
#pragma once
#include <vector>
#include <map>
#include <string>
#include <cstdint>

namespace fontmaster {
namespace utils {

class POSTParser {
private:
    const std::vector<uint8_t>& fontData;
    uint32_t postOffset;
    std::map<uint16_t, std::string> glyphNames;
    uint16_t numGlyphs;
    
public:
    POSTParser(const std::vector<uint8_t>& data, uint32_t offset, uint16_t glyphCount);
    bool parse();
    const std::map<uint16_t, std::string>& getGlyphNames() const;
};

}
}

--------------------------------

./include/fontmaster/TTFUtils.h
#pragma once
#include <vector>
#include <string>
#include <cstdint>
#include <cstring>
#include <algorithm>
#include <stdexcept>

namespace fontmaster {
namespace utils {

#pragma pack(push, 1)
struct TableRecord {
    char tag[4];
    uint32_t checksum;
    uint32_t offset;
    uint32_t length;
};

struct TTFHeader {
    uint32_t sfntVersion;
    uint16_t numTables;
    uint16_t searchRange;
    uint16_t entrySelector;
    uint16_t rangeShift;
};
#pragma pack(pop)

class TTFReader {
private:
    const std::vector<uint8_t>& data;
    size_t pos;
    
public:
    TTFReader(const std::vector<uint8_t>& fontData) : data(fontData), pos(0) {}
    
    uint8_t readUInt8() {
        if (pos >= data.size()) throw std::runtime_error("Read beyond buffer");
        return data[pos++];
    }
    
    int8_t readInt8() {
        return static_cast<int8_t>(readUInt8());
    }
    
    uint16_t readUInt16() {
        if (pos + 2 > data.size()) throw std::runtime_error("Read beyond buffer");
        uint16_t value = (data[pos] << 8) | data[pos + 1];
        pos += 2;
        return value;
    }
    
    int16_t readInt16() {
        return static_cast<int16_t>(readUInt16());
    }
    
    uint32_t readUInt32() {
        if (pos + 4 > data.size()) throw std::runtime_error("Read beyond buffer");
        uint32_t value = (data[pos] << 24) | (data[pos + 1] << 16) | 
                        (data[pos + 2] << 8) | data[pos + 3];
        pos += 4;
        return value;
    }
    
    void seek(size_t newPos) {
        if (newPos >= data.size()) throw std::runtime_error("Seek beyond buffer");
        pos = newPos;
    }
    
    size_t tell() const { return pos; }
    
    std::vector<uint8_t> readBytes(size_t count) {
        if (pos + count > data.size()) throw std::runtime_error("Read beyond buffer");
        std::vector<uint8_t> result(data.begin() + pos, data.begin() + pos + count);
        pos += count;
        return result;
    }
    
    std::string readString(size_t length) {
        if (pos + length > data.size()) throw std::runtime_error("Read beyond buffer");
        std::string result(data.begin() + pos, data.begin() + pos + length);
        pos += length;
        return result;
    }
    
    bool checkTag(const char* tag) {
        if (pos + 4 > data.size()) return false;
        return memcmp(data.data() + pos, tag, 4) == 0;
    }
};

std::vector<TableRecord> parseTTFTables(const std::vector<uint8_t>& fontData);
bool hasTable(const std::vector<TableRecord>& tables, const std::string& tableTag);
const TableRecord* findTable(const std::vector<TableRecord>& tables, const std::string& tableTag);

}
}

--------------------------------

./include/fontmaster/TTFRebuilder.h
#ifndef TTFRebuilder_H
#define TTFRebuilder_H

#include <vector>
#include <string>
#include <map>
#include <functional>
#include <cstdint>

namespace fontmaster {

namespace utils {
    struct TTFHeader;
    struct TableRecord;
    std::vector<TableRecord> parseTTFTables(const std::vector<uint8_t>& data);
}

class TTFRebuilder {
public:
    struct GlyphInfo {
        uint32_t offset;
        uint32_t length;
        uint16_t advanceWidth;
        int16_t leftSideBearing;
        bool isEmpty;
    };

    struct NameRecord {
        uint16_t platformID;
        uint16_t encodingID;
        uint16_t languageID;
        uint16_t nameID;
        uint16_t length;
        uint16_t offset;
    };

    struct CompositeGlyphStats {
        uint16_t maxPoints;
        uint16_t maxContours;
        uint16_t maxComponents;
        uint16_t maxDepth;
    };

    struct TableInfo {
        std::string tag;
        uint32_t originalOffset;
        uint32_t originalLength;
        uint32_t newOffset;
        uint32_t newLength;
        bool modified;
        std::vector<uint8_t> data;
    };

    TTFRebuilder(const std::vector<uint8_t>& fontData);
    
    void markTableModified(const std::string& tag);
    void setTableData(const std::string& tag, const std::vector<uint8_t>& data);
    const std::vector<uint8_t>* getTableData(const std::string& tag) const;
    bool hasTable(const std::string& tag) const;
    void setTableRebuildHandler(const std::string& tag, std::function<void(const std::string&)> handler);
    
    virtual std::vector<uint8_t> rebuild() = 0;
    
    void setNumGlyphs(uint16_t newNumGlyphs);
    void setNumberOfHMetrics(uint16_t newNumHMetrics);

    // Основные методы обновления таблиц
    void updateGlyfTable(const std::string& glyfTag = "glyf");
    void updateLocaTable(const std::string& locaTag = "loca");
    void updateHmtxTable(const std::string& hmtxTag = "hmtx");
    void updateHheaTable(const std::string& hheaTag = "hhea");
    void updateMaxpTable(const std::string& maxpTag = "maxp");

private:
    std::vector<uint8_t> originalData;
    std::vector<uint8_t> newData;
    std::map<std::string, TableInfo> tables;
    std::vector<std::string> tableOrder;
    std::map<std::string, std::function<void(const std::string&)>> rebuildHandlers;
    
    std::vector<GlyphInfo> glyphOffsets;
    uint16_t numGlyphs;
    uint16_t numHMetrics;
    bool locaShortFormat;

    // Вспомогательные методы для работы с данными
    uint16_t getUInt16(const std::vector<uint8_t>& data, size_t offset) const;
    uint32_t getUInt32(const std::vector<uint8_t>& data, size_t offset) const;
    int16_t getInt16(const std::vector<uint8_t>& data, size_t offset) const;
    void setUInt16(std::vector<uint8_t>& data, size_t offset, uint16_t value);
    void setUInt32(std::vector<uint8_t>& data, size_t offset, uint32_t value);
    void setInt16(std::vector<uint8_t>& data, size_t offset, int16_t value);
    
    // Методы парсинга оригинальной структуры
    void parseOriginalStructure();
    bool parseHeadTable();
    bool parseMaxpTable();
    bool parseHheaTable();
    bool parseLocaTable();
    void parseGlyfTable();
    
    // Методы пересборки таблиц
    void rebuildTable(const std::string& tag);
    void rebuildGlyfTable(const std::string& tag);
    void rebuildLocaTable(const std::string& tag);
    void rebuildHmtxTable(const std::string& tag);
    void rebuildHheaTable(const std::string& tag);
    void rebuildMaxpTable(const std::string& tag);
    void rebuildNameTable(const std::string& tag);
    void rebuildOS2Table(const std::string& tag);
    void rebuildHeadTable(const std::string& tag);
    void rebuildPostTable(const std::string& tag);
    
    // Методы расчета и обновления
    void calculateGlyphOffsets();
    uint32_t parseSimpleGlyphLength(const std::vector<uint8_t>& data, uint32_t offset) const;
    uint32_t parseCompositeGlyphLength(const std::vector<uint8_t>& data, uint32_t offset) const;
    void calculateGlyphMetrics();
    void calculateHMetrics();
    void recalculateFontMetrics();
    void updateHheaMetrics();
    void updateOS2Metrics();
    void updateMaxpTableValues();
    
    // Методы для работы с точками и контурами
    uint16_t calculateSimpleGlyphPoints(const std::vector<uint8_t>& data, uint32_t offset) const;
    CompositeGlyphStats calculateCompositeGlyphStats(const std::vector<uint8_t>& data, uint32_t offset) const;
    CompositeGlyphStats analyzeGlyphForComposite(const std::vector<uint8_t>& data, uint32_t offset) const;
    
    // Методы для работы с таблицей имен
    void updateNameTableChecksum();
    void fixMacRomanEncoding(std::vector<uint8_t>& stringData);
    void fixUnicodeEncoding(std::vector<uint8_t>& stringData);
    
    // Методы для работы с таблицей post
    void updatePostTableFormat2();
    uint16_t calculateStandardGlyphNameIndex(uint16_t glyphIndex);
    uint16_t getUnicodeFromCmap(uint16_t glyphIndex);
    uint16_t findGlyphInFormat4Subtable(const std::vector<uint8_t>& cmapData, uint32_t offset, uint16_t glyphIndex);
    uint16_t findGlyphInFormat12Subtable(const std::vector<uint8_t>& cmapData, uint32_t offset, uint16_t glyphIndex);
    bool isCompositeGlyph(uint16_t glyphIndex);
    uint16_t generateUnicodeGlyphNameIndex(uint16_t unicodeValue);
    uint16_t generateCompositeGlyphName(uint16_t glyphIndex);
    uint16_t generateDefaultGlyphName(uint16_t glyphIndex);
    
    // Методы валидации
    void validateTableData(const std::string& tag, size_t minSize) const;
    void validateGlyphData() const;
    
    // Методы для сборки финального файла
    void updateTableOffsets();
    void rebuildTableDirectory();
    void updateHeadTableChecksumAdjustment();
    uint32_t calculateTableChecksum(const std::vector<uint8_t>& data) const;
    uint32_t calculateChecksum(const std::vector<uint8_t>& data) const;
};

} // namespace fontmaster

#endif // TTFRebuilder_H

--------------------------------

./include/fontmaster/CBDT_CBLC_Handler.h
#ifndef CBDT_CBLC_HANDLER_H
#define CBDT_CBLC_HANDLER_H

#include "fontmaster/FontMaster.h"
#include <memory>
#include <vector>

namespace fontmaster {

class CBDT_CBLC_Handler : public FontFormatHandler { // Исправлено: добавлен public
public:
    CBDT_CBLC_Handler() = default;
    virtual ~CBDT_CBLC_Handler() = default;
    
    bool canHandle(const std::string& filepath) override;
    
    std::unique_ptr<Font> loadFont(const std::string& filepath) override;
    
    FontFormat getFormat() const override { 
        return FontFormat::CBDT_CBLC; 
    }

private:
    std::vector<std::string> supportedFormats;
};

} // namespace fontmaster

#endif // CBDT_CBLC_HANDLER_H

--------------------------------

./include/fontmaster/MAXPParser.h
#pragma once
#include <vector>
#include <cstdint>

namespace fontmaster {
namespace utils {

class MAXPParser {
private:
    const std::vector<uint8_t>& fontData;
    uint32_t maxpOffset;
    uint16_t numGlyphs;
    
public:
    MAXPParser(const std::vector<uint8_t>& data, uint32_t offset);
    bool parse();
    uint16_t getNumGlyphs() const;
};

}
}

--------------------------------

./include/fontmaster/NAMEParser.h
#ifndef NAMEPARSER_H
#define NAMEPARSER_H

#include <vector>
#include <string>
#include <cstdint>

namespace fontmaster {
namespace utils {

class NAMEParser {
public:
    struct NameRecord {
        uint16_t platformID;
        uint16_t encodingID;
        uint16_t languageID;
        uint16_t nameID;
        std::string value;
    };

    NAMEParser(const std::vector<uint8_t>& fontData);
    
    bool parse();
    const std::vector<NameRecord>& getNameRecords() const;
    std::vector<NameRecord> getNameRecordsByID(uint16_t nameID) const;
    std::vector<NameRecord> getPostScriptNames() const;

private:
    std::vector<uint8_t> fontData;
    std::vector<NameRecord> nameRecords;

    void parseNameRecord(uint32_t recordOffset, uint16_t stringOffset);
    std::string readString(const uint8_t* data, uint16_t length, uint16_t platformID, uint16_t encodingID);
    std::string readMacString(const uint8_t* data, uint16_t length);
    std::string readWindowsString(const uint8_t* data, uint16_t length, uint16_t encodingID);
    std::string readUnicodeString(const uint8_t* data, uint16_t length);
    uint16_t readUInt16(const uint8_t* data);
};

} // namespace utils
} // namespace fontmaster

#endif // NAMEPARSER_H

--------------------------------

./include/fontmaster/CBDT_CBLC_Rebiulder.h
#ifndef CBDT_CBLC_REBUILDER_H
#define CBDT_CBLC_REBUILDER_H

#include "fontmaster/TTFRebuilder.h"
#include "fontmaster/CBDT_CBLC_Parser.h"
#include <vector>
#include <map>

namespace fontmaster {

class CBDT_CBLC_Rebuilder : public TTFRebuilder {
public:
    CBDT_CBLC_Rebuilder(const std::vector<uint8_t>& fontData, 
                       const std::map<uint32_t, StrikeRecord>& strikes,
                       const std::vector<uint16_t>& removedGlyphs);
    virtual ~CBDT_CBLC_Rebuilder() = default;
    
    std::vector<uint8_t> rebuild() override;
    
private:
    std::map<uint32_t, StrikeRecord> strikes;
    std::vector<uint16_t> removedGlyphs;
    
    void rebuildCBLCTable(std::vector<uint8_t>& cblcData);
    void rebuildCBDTTable(std::vector<uint8_t>& cbdtData);
    void rebuildStrike(std::vector<uint8_t>& cblcData, const StrikeRecord& strike);
    void rebuildIndexSubtable1(std::vector<uint8_t>& cblcData, const StrikeRecord& strike);
    
    std::vector<uint8_t> createUpdatedFont(const std::vector<uint8_t>& newCBLCTable, 
                                         const std::vector<uint8_t>& newCBDTTable);
    
    void appendUInt32(std::vector<uint8_t>& data, uint32_t value);
    void appendUInt16(std::vector<uint8_t>& data, uint16_t value);
    void setUInt32(std::vector<uint8_t>& data, size_t offset, uint32_t value);
};

} // namespace fontmaster

#endif // CBDT_CBLC_REBUILDER_H

--------------------------------

./include/fontmaster/FontMaster.h
#pragma once
#include <string>
#include <vector>
#include <memory>
#include <cstdint>
#include <stdexcept>  // Добавляем для исключений

namespace fontmaster {

enum class FontFormat {
    UNKNOWN,
    CBDT_CBLC,  // Google
    SBIX,       // Apple  
    COLR_CPAL,  // Microsoft
    SVG,        // Adobe
    STANDARD    // Обычный шрифт
};

struct GlyphInfo {
    std::string name;
    uint32_t unicode;
    std::vector<uint8_t> image_data;
    std::string format; // "png", "svg", "colr"
    size_t data_size;
};

// Предварительные объявления
class Font;
class FontFormatHandler;

// Исключения
class FontException : public std::runtime_error {
public:
    FontException(const std::string& message) : std::runtime_error(message) {}
};

class FontLoadException : public FontException {
public:
    FontLoadException(const std::string& filename, const std::string& reason)
        : FontException("Failed to load font '" + filename + "': " + reason) {}
};

class FontFormatException : public FontException {
public:
    FontFormatException(const std::string& format, const std::string& reason)
        : FontException("Unsupported font format '" + format + "': " + reason) {}
};

class FontSaveException : public FontException {
public:
    FontSaveException(const std::string& filename, const std::string& reason)
        : FontException("Failed to save font '" + filename + "': " + reason) {}
};

class GlyphNotFoundException : public FontException {
public:
    GlyphNotFoundException(const std::string& glyphName)
        : FontException("Glyph not found: " + glyphName) {}
};

class Font {
public:
    virtual ~Font() = default;
    
    virtual bool load() = 0;
    virtual const std::vector<uint8_t>& getFontData() const = 0;
    virtual void setFontData(const std::vector<uint8_t>& data) = 0;
    
    static std::unique_ptr<Font> load(const std::string& filepath);
    
    virtual FontFormat getFormat() const = 0;
    virtual bool save(const std::string& filepath) = 0;
    
    // Основные операции
    virtual bool removeGlyph(const std::string& glyphName) = 0;
    virtual bool removeGlyph(uint32_t unicode) = 0;
    virtual bool replaceGlyphImage(const std::string& glyphName, 
                                  const std::vector<uint8_t>& newImage) = 0;
    
    // Информация
    virtual std::vector<GlyphInfo> listGlyphs() const = 0;
    virtual GlyphInfo getGlyphInfo(const std::string& glyphName) const = 0;
    
    // Утилиты
    virtual std::string findGlyphName(uint32_t unicode) const = 0;
};

class FontFormatHandler {
public:
    virtual ~FontFormatHandler() = default;
    virtual bool canHandle(const std::string& filepath) = 0;
    virtual std::unique_ptr<Font> loadFont(const std::string& filepath) = 0;
    virtual FontFormat getFormat() const = 0;
};

} // namespace fontmaster

--------------------------------

./include/fontmaster/CBDT_CBLC_Parser.h
#pragma once

#include <cstdint>
#include <vector>
#include <unordered_map>
#include <map>
#include <string>

namespace fontmaster {

/**
 * Описание изображения глифа (используется и в парсере, и в ребилдере).
 * Поля публичные для простоты доступа.
 */
struct GlyphImage {
    uint16_t glyphID = 0;
    uint16_t imageFormat = 0;   // формат изображения (см. спецификацию CBDT)
    uint32_t offset = 0;        // относительный offset внутри CBDT (у нас хранится как смещение от начала CBDT)
    uint32_t length = 0;        // длина извлечённых данных
    std::vector<uint8_t> data;  // реальные байты изображения (PNG/JPEG/TIFF/bitmap)
    uint16_t width = 0;
    uint16_t height = 0;
    int16_t bearingX = 0;
    int16_t bearingY = 0;
    uint16_t advance = 0;
};

/**
 * Описание страйка (strike) — набор растровых глифов для одного ppem/resolution.
 */
struct StrikeRecord {
    uint16_t ppem = 0;
    uint16_t resolution = 72;
    std::vector<uint16_t> glyphIDs;
    std::map<uint16_t, GlyphImage> glyphImages;
};

class CBDT_CBLC_Parser {
public:
    explicit CBDT_CBLC_Parser(const std::vector<uint8_t>& fontData);

    /**
     * Выполнить разбор CBLC и CBDT таблиц. Возвращает true при успехе.
     */
    bool parse();

    /**
     * Доступ к разобранным страйкам: id -> StrikeRecord.
     * В парсере мы используем индекс-номер страйка (0..N-1).
     */
    const std::map<uint32_t, StrikeRecord>& getStrikes() const { return strikes; }

    /**
     * Список глифов, которые парсер считает "removed" (не имеют cmap-отображения).
     */
    const std::vector<uint16_t>& getRemovedGlyphs() const { return removedGlyphs; }

private:
    const std::vector<uint8_t>& fontData;
    std::map<uint32_t, StrikeRecord> strikes;
    std::vector<uint16_t> removedGlyphs;

    // Основные шаги
    bool parseCBLCTable(uint32_t offset, uint32_t length);
    bool parseCBDTTable(uint32_t offset, uint32_t length);
    bool parseStrike(uint32_t offset, uint32_t strikeIndex);
    bool parseIndexSubtable(uint32_t offset, StrikeRecord& strike);

    // Форматы индексов
    bool parseIndexFormat1(uint32_t offset, StrikeRecord& strike,
                           uint16_t firstGlyph, uint16_t lastGlyph,
                           uint16_t imageFormat, uint32_t imageDataOffset);
    bool parseIndexFormat2(uint32_t offset, StrikeRecord& strike,
                           uint16_t firstGlyph, uint16_t lastGlyph,
                           uint16_t imageFormat, uint32_t imageDataOffset);
    bool parseIndexFormat5(uint32_t offset, StrikeRecord& strike,
                           uint16_t firstGlyph, uint16_t lastGlyph,
                           uint16_t imageFormat, uint32_t imageDataOffset);

    // Извлечение данных изображения
    bool extractGlyphImageData(uint32_t imageOffset, GlyphImage& image, uint32_t cbdtBase, uint32_t cbdtLength);
    bool extractBitmapData(const uint8_t* data, size_t available, GlyphImage& image);
    bool extractPNGData(const uint8_t* data, size_t available, GlyphImage& image);
    bool extractJPEGData(const uint8_t* data, size_t available, GlyphImage& image);
    bool extractTIFFData(const uint8_t* data, size_t available, GlyphImage& image);
    bool parseTIFFDirectory(const uint8_t* data, size_t available, uint32_t ifdOffset, GlyphImage& image, bool bigEndian);

    // Вспомогательные чтения (big endian)
    uint32_t readUInt32(const uint8_t* p) const;
    uint16_t readUInt16(const uint8_t* p) const;
    uint16_t readUInt16(const uint8_t* p, bool bigEndian) const;
    uint32_t readUInt32(const uint8_t* p, bool bigEndian) const;

    // Парсинг cmap (опционально использует utils::CMAPParser при наличии)
    bool parseCMAPTable(uint32_t offset, uint32_t length);
    uint32_t cbdtTableOffset = 0;
    uint32_t cbdtTableLength = 0;
};

} // namespace fontmaster

--------------------------------

./include/fontmaster/CBDT_CBLC_Rebuilder.h
#pragma once
#include <cstdint>
#include <vector>
#include <unordered_map>
#include <string>
#include <set>

namespace fontmaster {

/**
 * @brief Описание одного изображения глифа в CBDT.
 */
struct GlyphImage {
    std::vector<uint8_t> data;  ///< Сырые бинарные данные изображения (PNG, JPEG и т.д.)
    uint16_t width = 0;         ///< Ширина изображения (если доступно)
    uint16_t height = 0;        ///< Высота изображения (если доступно)
};

/**
 * @brief Описание страйка (strike) — набора цветных глифов для определённого размера.
 */
struct StrikeRecord {
    uint16_t ppem = 0;                 ///< Размер пикселей на EM
    uint16_t resolution = 72;          ///< DPI
    std::vector<uint16_t> glyphIDs;    ///< Список глифов в страйке
    std::unordered_map<uint16_t, GlyphImage> glyphImages; ///< Данные по каждому глифу
};

/**
 * @brief Класс для пересборки цветных таблиц CBDT/CBLC шрифта.
 * Используется после парсера для восстановления шрифта с модифицированными глифами.
 */
class CBDT_CBLC_Rebuilder {
public:
    /// Конструктор принимает исходные бинарные данные шрифта
    explicit CBDT_CBLC_Rebuilder(const std::vector<uint8_t>& fontData)
        : fontData(fontData) {}

    /**
     * @brief Добавить страйк (набор глифов)
     */
    void addStrike(uint16_t id, const StrikeRecord& strike) {
        strikes[id] = strike;
    }

    /**
     * @brief Удалить глиф из всех страйков.
     */
    void removeGlyph(uint16_t glyphId) {
        removedGlyphs.push_back(glyphId);
    }

    /**
     * @brief Собрать обновлённый шрифт с новыми таблицами CBDT и CBLC.
     * @return Бинарные данные шрифта (TTF)
     */
    std::vector<uint8_t> rebuild();

private:
    const std::vector<uint8_t>& fontData;
    std::unordered_map<uint16_t, StrikeRecord> strikes;
    std::vector<uint16_t> removedGlyphs;

    void rebuildCBLCTable(std::vector<uint8_t>& cblc);
    void rebuildCBDTTable(std::vector<uint8_t>& cbdt);
    void rebuildStrike(std::vector<uint8_t>& buf, const StrikeRecord& strike);
    void rebuildIndexSubtable1(std::vector<uint8_t>& buf, const StrikeRecord& strike,
                               uint16_t firstGlyph, uint16_t lastGlyph);

    std::vector<uint8_t> createUpdatedFont(const std::vector<uint8_t>& newCBLCTable,
                                           const std::vector<uint8_t>& newCBDTTable);
};

} // namespace fontmaster
